<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Spring笔记（四）—— IOC 容器之 Bean 的生命周期]]></title>
      <url>%2F2016%2F11%2F16%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[Initialization 回调org.springframework.beans.factory.InitializingBean 接口允许 bean 在容器设置完所有属性后执行初始化工作，初始化工作在实现 InitializingBean 的类中的 afterPropertiesSet() 方法中执行。此外，初始化工作也可通过 @PostConstruct 注解来指定执行初始化工作的方法；或者指定一个 POJO 的初始化方法，然后在 XML 文件中使用 init-method 属性指定在该方法中执行初始化操作。 实现 InitializingBean 接口1&lt;bean id="exampleInitBean" class="examples.ExampleBean"/&gt; 12345public class ExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 使用 @PostConstruct 注解123456public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125;&#125; 使用 init-method 属性1&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt; 12345public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125; Destroy 回调org.springframework.beans.factory.DisposableBean 接口允许 bean 使用销毁回调，销毁工作在实现 DisposableBean 的类中的 destroy() 方法中执行。注解方法使用 @PreDestroy，XML 文件指定 destroy-method 属性即可。 实现 InitializingBean 接口1&lt;bean id="exampleInitBean" class="examples.ExampleBean"/&gt; 12345public class ExampleBean implements InitializingBean &#123; public void destroy() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 使用 @PostConstruct 注解123456public class CachingMovieLister &#123; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; 使用 init-method 属性1&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt; 12345public class ExampleBean &#123; public void cleanup() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 默认的 initialization 和 destroy 方法当做 initialization 和 destroy 工作时，使用 init(), initialize(), dispose() 等类似的方法名有助于我们识别方法的作用。每次我们都需要为每个 bean 设置 init-method 或 destroy-method 属性指定生命周期的回调方法，有一个更加简便的方法，即在 元素中使用 default-init-method 属性指定初始化的方法，则默认 元素下的所有 bean 的初始化方法均为 init()。12345&lt;beans default-init-method="init"&gt; &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt; &lt;property name="blogDao" ref="blogDao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112public class DefaultBlogService implements BlogService &#123; private BlogDao blogDao; public void setBlogDao(BlogDao blogDao) &#123; this.blogDao = blogDao; &#125; // this is (unsurprisingly) the initialization callback method public void init() &#123; if (this.blogDao == null) &#123; throw new IllegalStateException("The [blogDao] property must be set."); &#125; &#125;&#125; default-destroy-method 属性的使用方法也和 default-init-method 一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（三）—— IOC 容器之 BeanFactory 和 ApplicationContext]]></title>
      <url>%2F2016%2F11%2F13%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%20BeanFactory%20%E5%92%8C%20ApplicationContext%2F</url>
      <content type="text"><![CDATA[简介BeanFactory 是 Spring 框架最核心的接口，它提高了高级 IOC 的配置机制。BeanFactory 使管理不同类型的 Java 对象成为可能，ApplicationContext 建立在 BeanFactory 的基础之上，提供了更多面向应用的功能，提供了国际化支持和框架事件体系，更易于创建实际应用。BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身，ApplicationContext 面向使用 Spring 框架的开发者。 BeanFactoryBeanFactory 提供了 Spring IOC 的基础功能，但它只能在第三方框架中直接使用。和 BeanFactory 相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，仍然存在于 Spring 中用于与 Spring 集成的大量第三方框架向后兼容的作用。BeanFactory 通常使用在运行于资源有限（内存消耗严重）的嵌入式应用中。 使用 BeanFactory 实现注册一个后处理器（PostProcessor）： 123456DefaultListableBeanFactory factory = new DefaultListableBeanFactory();// populate the factory with bean definitions// now register any needed BeanPostProcessor instancesMyBeanPostProcessor postProcessor = new MyBeanPostProcessor();factory.addBeanPostProcessor(postProcessor);// now start using the factory 使用 BeanFactory 实现注册一个 BeanFactoryPostProcessor： 12345678DefaultListableBeanFactory factory = new DefaultListableBeanFactory();XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));// bring in some property values from a Properties filePropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();cfg.setLocation(new FileSystemResource("jdbc.properties"));// now actually do the replacementcfg.postProcessBeanFactory(factory); ApplicationContextApplicationContext 继承自 BeanFactory，提供了更多面向实际应用的功能。在 BeanFactory 中，很多功能需要以编程的方式实现，而在 ApplicationContext 中则可以通过配置的方式实现。 下图为 ApplicationContext 的继承体系图： ApplicationContext 的主要实现类是 ClassPathXmlApplicationContext，FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext，第一个默认从类路径加载配置文件，第二个默认从文件系统中装载配置文件，第三个可直接传入注解类，通过 register(Class…) 注册类或 scan(String…) 扫描路径 classpath 逐个注册类。 如上图所示，ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此之上还通过其他的接口扩展了 BeanFactory 的功能。这类接口包括： ApplicationEventPublisher：让容器拥有发布 ApplicationContext 事件的功能，包括容器启动时间、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件，并对事件进行响应处理。在 ApplicationContext 抽象实现类 AbstractApplicationContext 中，可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生 ApplicationContext 事件时通知这些事件监听者。 MessageSource：为应用提供 i18n 国际化消息访问的功能。 ResourcePatternResolver：所有 ApplicationContext 实现类都实现了通过 Ant 风格的资源文件路径装载 Spring 的配置文件。 Lifecycle：该接口于 Spring2.0 加入，提供了 start() 和 stop() 两个方法，主要用于控制异步处理过程。具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现，ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。 ConfigurableApplicationContext 继承自 ApplicationContext，增加了两个主要的方法：refresh() 和 close()，让 ApplicationContext 具有启动、刷新和关闭上下文的能力。在 ApplicationContext 关闭时，调用 refresh 可启动 ApplicationContext；在启动状态下调用，则清除缓存并重新装载配置信息。调用 close 关闭 ApplicationContext。 ApplicationContext 的初始化：ApplicationContext 在实例化后和 BeanFactory 一样调用 getBean(beanName) 返回 Bean；在初始化时，BeanFactory 初始化容器时并未实例化 Bean 直至第一次访问 Bean，ApplicationContext 在初始化上下文时实例化所有单实例的 Bean。和基于 XML 文件配置方式的相比，类注解的配置方式可以很容易地让开发者控制 Bean 的初始化过程。 配置文件在类路径下，优先使用 ClassPathXmlApplicationContext，“com/example/context/beans.xml” 等同于 “classpath:com/example/context/beans.xml”： 1234ApplicationContext ctx = new ClassPathXmlApplicationContext("com/example/context/beans.xml");ApplicationContext ctx = new ClassPathXmlApplicationContext( new String[]&#123; "com/beans1.xml", "com/beans2.xml" &#125;); 配置文件在类路径下，优先使用 FileSystemXmlApplicationContext，“com/example/context/beans.xml” 等同于 “file:com/example/context/beans.xml”： 12ApplicationContext ctx = new FileSystemXmlApplicationContext("com/example/context/beans.xml"); 需要解析的是注解类，使用 AnnotationConfigApplicationContext： Bean 类： 1234567891011121314151617181920package com.lake.context;public class Car &#123; private String brand; private int maxSpeed; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125;&#125; 带注解的 POJO 类： 12345678910111213package com.lake.context;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class Beans &#123; @Bean(name = "car") public Car buildCar() &#123; Car car = new Car(); car.setBrand("奔驰"); car.setMaxSpeed(300); return car; &#125;&#125; 通过带 @Configuration 的 POJO 类启动容器： 123456789package com.lake.context;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class AnnotationApplicantionContext &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(Beans.class); Car car = context.getBean("car", Car.class); &#125;&#125; WebApplicationContextWebApplicationContext 为 Web 应用而准备，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。Spring 提供了工具类 WebApplicationContextUtils，通过 getWebApplicationContext(ServletContext sc) 获取 WebApplicationContext 实例。 ConfigurableWebApplicationContext 继承自 WebApplicationContext，它允许通过配置的方式实例化 WebApplicationContext，它有两个重要的方法： setServletContext(ServletContext servletContext)：为 Spring 设置 WebApplicationContext。 setConfigLocations(String[] configLocations)：设置 Spring 配置文件地址，相对于 Web 根目录，如 /WEB-INF/lake-dao.xml，/WEB-INF/lake-service.xml 等。但用户也可使用带资源类型前缀的地址，如 classpath:com/example/context/beans.xml 等。 WebApplicationContext 初始化WebApplicationContext 需要 ServletContext 实例，它必须在拥有 Web 容器的情况下才能完成启动工作，和通常的 Web 开发类似，在 web.xml 中配置自启动的 Servlet 或容器监听器（ServletContextListener），即可完成启动 Spring WebApplicationContext 的工作。Spring 提供了用于启动 WebApplicationContext 的 Servlet 和 Web 容器监听器： org.springframework.web.context.ContextLoaderServlet org.springframework.web.context.ContextLoaderListener 两者都实现了启动 WebApplicationContext 实例的逻辑，只要根据 Web 容器的具体情况选择其一，并在 web.xml 中完成配置即可。 ContextLoaderListener 启动 WebApplicationContext:123456789&lt;!-- 指定配置文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 设置Web容器监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 在不支持容器监听器的低版本 Web 容器中，使用 ContextLoaderServlet：1234567891011&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 声明自启动的Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springContextLoaderServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;!-- 启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 标准和自定义事件ApplicationContext 通过 ApplicationEvent 和 ApplicationListener 接口提供事件处理，当某个 bean 实现了 ApplicationListener 接口时，当 ApplicationEvent 发布给 ApplicationContext 时，该 bean 会被告知。 标准事件 ContextRefreshedEvent：当 ApplicationContext 被初始化或刷新时发布事件。这里的初始化是指所有的 beans 被加载，后处理器 beans 被检测并激活，单例被预实例化，ApplicationContext 对象已准备好并可用。当上下文关闭时，refresh 可以被多次触发，这样的 ApplicationContext 支持热刷新。XmlWebApplicationContext 支持热刷新，而 GenericApplicationContext 不支持。 ContextStartedEvent：ApplicationContext 被启动时发布事件，使用 ConfigurableApplicationContext 接口的 start() 方法。这里的启动意味着 beans 接收一个显式的启动信号，该信号用于在显式的停止之后重新启动 beans，也可以用于启动没有被配置成自动启动的组件。 ContextStoppedEvent：ApplicationContext 被停止时发布事件，使用 ConfigurableApplicationContext 接口的 stop() 方法。 RequestHandledEvent：告知所有 beans 一个 HTTP 请求已被处理的特定的 web 事件，当请求完成时事件将会被发布，该事件只能通过 Spring 的 DispatcherServlet 应用于 Web 应用中。 自定义事件自定义事件需要继承 Spring 的 ApplicationEvent 基类：12345678910public class BlackListEvent extends ApplicationEvent &#123; private final String address; private final String test; public BlackListEvent(Object source, String address, String test) &#123; super(source); this.address = address; this.test = test; &#125; // accessor and other methods...&#125; 调用 ApplicationEventPublisher 的 publishEvent() 方法发布自定义的 ApplicationEvent，该类需要实现 ApplicationEventPublisherAware 接口并作为 bean 来注册。在配置期间，Spring 容器会检测到实现了 ApplicationEventPublisherAware 接口的 EmailService 并自动的调用 setApplicationEventPublisher() 方法。123456789101112131415161718public class EmailService implements ApplicationEventPublisherAware &#123; private List&lt;String&gt; blackList; private ApplicationEventPublisher publisher; public void setBlackList(List&lt;String&gt; blackList) &#123; this.blackList = blackList; &#125; public void setApplicationEventPublisher(ApplicationEventPublisher publisher) &#123; this.publisher = publisher; &#125; public void sendEmail(String address, String text) &#123; if (blackList.contains(address)) &#123; BlackListEvent event = new BlackListEvent(this, address, text); publisher.publishEvent(event); return; &#125; // send email... &#125;&#125; 创建一个实现 ApplicationListener 接口的类，并作为 bean 来注册，以此接受自定义的 ApplicationEvent。123456789public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; &#123; private String notificationAddress; public void setNotificationAddress(String notificationAddress) &#123; this.notificationAddress = notificationAddress; &#125; public void onApplicationEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress... &#125;&#125; 下面的代码用于配置和注册上述的类：123456789101112&lt;bean id="emailService" class="example.EmailService"&gt; &lt;property name="blackList"&gt; &lt;list&gt; &lt;value&gt;known.spammer@example.org&lt;/value&gt; &lt;value&gt;known.hacker@example.org&lt;/value&gt; &lt;value&gt;john.doe@example.org&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="blackListNotifier" class="example.BlackListNotifier"&gt; &lt;property name="notificationAddress" value="blacklist@example.org"/&gt; &lt;/bean&gt; 当 emailService 的 sendEmail() 方法被调用时，如果有任何邮件需要被加入黑名单，那么自定事件 BlackListEvent 会被发布。blackListNotifier bean 被注册作为 ApplicationListener 并接收 BlackListEvent。 基于注解的事件监听器12345678910public class BlackListNotifier &#123; private String notificationAddress; public void setNotificationAddress(String notificationAddress) &#123; this.notificationAddress = notificationAddress; &#125; @EventListener public void processBlackListEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress... &#125;&#125; 异步监听器12345@EventListener@Asyncpublic void processBlackListEvent(BlackListEvent event) &#123; // BlackListEvent is processed in a separate thread&#125; 顺序监听器12345@EventListener@Order(42)public void processBlackListEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress...&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（二）—— 基本概念的理解]]></title>
      <url>%2F2016%2F11%2F12%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[控制反转（IOC）控制反转（Inversion of Control），即依赖注入（Dependency Injection），它们两个是一个东西的两种不同的说法。依赖注入是一个程序设计模式和架构模型，是控制反转的特殊实现，它指一个对象应用另外一个对象来提供一个特殊的能力。IOC 是 Spring 的核心，理解它的时候可以分为控制和反转两步来理解。举个例子：你现在接到一份工作，但是你没空，你把工作交给你的好友来完成，你对工作如何完成已不关心，控制权移交到你的好友手中，他可以决定如何完成工作，你只需要等待结果即可。如上所述，控制即对工作的控制权，反转可理解为原先你所掌握的工作的控制权移交到好友身上。在 Spring 中理解为某一接口具体实现类的控制权从调用类中移除，转而由第三方控制（类似对成员变量的赋值的控制权从代码移交到 xml 配置文件中）。依赖注入理解为让调用者对某一接口实现类的依赖关系由第三方（容器或协助类）注入，以移除调用类对某一接口实现类的依赖。 面向切面编程（AOP）面相切面编程（AOP）是对面相对象编程（OOP）的补充，OOP 主要的模块单元是 class (类)，而 AOP 是 aspect（切面），切面使得诸如事务管理等跨越多个类型和对象的关注点模块化。AOP 通过横向抽取机制，为无法通过纵向继承体系进行抽象的类的重复性代码提供了解决方案。 连接点（Join point）在程序执行过程中具有边界性质的特定点，比如某个类初始化前后、类的某个方法调用前后或者处理异常的时候。在 Spring AOP 中，一个连接点总是代表一个方法的执行。 增强（Advice）在切面的某个特定的连接点上执行的动作。增强有各种类型，其中包括 around、before 和 after 等。Spring 以拦截器作增强模型，并维护一个以连接点为中心的拦截器链。 切点（Pointcut）用来匹配连接点的断言。增强关联一个切点表达式，并在匹配这个切入点的连接点上运行。AOP 通过切点定位特定的连接点：Spring 默认使用切点语法 AspectJ。通过数据库查询的概念来理解切点和连接点：连接点相当于数据库中的记录，而切点相当于查询条件，一个切点可以匹配多个连接点。 切面（Aspect）切面由切点和增强组成，包括横切逻辑和连接点的定义。在 Spring AOP 中，切面可以使用通用类（schema-based 基于模式的风格）或者在普通类中以 @Aspect 注解（@AspectJ 注解样式）来实现。 引介（Introduction）引介是一种特殊的增强，它为类添加一些属性和方法。一个业务类原先没有实现某个接口，通过 AOP 的引介功能，可以动态地为该业务添加接口的实现逻辑，让业务类成为该接口的实现类。例如：使用一个引介来使 bean 实现 IsModified 接口，以便简化缓存机制。 目标对象（Target object）被一个或多个切面所增强的对象。因为 Spring AOP 是使用运行时代理来实现的，所以这个对象总是一个代理对象。 代理（Proxy）一个类被 AOP 织入增强后，就生成一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。在 Spring 中，AOP 代理可以是 JDK 动态代理或者 CGLIB 代理。 织入（Weaving） 织入是将增强添加到目标类具体连接点上的过程。AOP 有三种织入方式： 编译期织入，要求特殊的 Java 编译器 类装载期织入，要求使用特殊的类装载器 动态代理织入，在运行期为目标类添加增强生成子类的方式 Spring 采用动态代理织入（即在运行时完成织入），而 AspectJ 采用编译期和类装载期织入。 Spring 框架组件列表 GroupId ArtifactId 描述 org.springframework spring-aop 支持基于代理的 AOP org.springframework spring-aspects 基于 AspectJ 的切面 org.springframework spring-beans 包含 Groovy 的 Beans 支持 org.springframework spring-context 应用程序上下文运行时，包括调度和远程抽象 org.springframework spring-context-support 支持将常见的第三方库集成到 Spring 应用程序上下文的类中 org.springframework spring-core Spring 核心，为其它模块所用 org.springframework spring-expression Spring 表达式（SpEL） org.springframework spring-instrument JVM 引导用的代理工具 org.springframework spring-instrument-tomcat Tomcat 的代理工具 org.springframework spring-jdbc JDBC 支持包，包括 DataSource 设置和 JDBC 访问支持 org.springframework spring-jms JMS 支持包，包括用于发送和接收 JMS 消息的帮助类 org.springframework spring-messaging 支持消息架构和协议 org.springframework spring-orm 对象/关系映射，包含对 JPA 和 Hibernate 支持 org.springframework spring-oxm 对象/XML映射 org.springframework spring-test 支持单元测试和集成测试的 Spring 组件 org.springframework spring-tx 事务基础设施，包括 DAO 支持和 JCA 集成 org.springframework spring-web Web 支持包，包括客户端和 Web 远程处理 org.springframework spring-webmvc REST Web 服务和 Web 应用程序实现的 model-view-controller org.springframework spring-webmvc-portlet MVC 实现在 Portlet 环境中的使用 org.springframework spring-websocket WebSocket 和 SockJS 实现，包含 STOMP 支持 参考资料：中文翻译《Spring Framework 4.x参考文档》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（一）—— 版本新特性]]></title>
      <url>%2F2016%2F11%2F12%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[1. spring 2.0 和 2.5 的新特性1.1 简介JDK 版本要在 1.4.2 以上，Java 5 和 Java 6 都支持。Spring 框架继续保持对 Java EE 1.3 及以后版本的兼容，完全支持 Java EE 5。对服务器（应用服务器和Web服务器）的支持： WebLogic：8.1、9.0、9.2、10 WebSphere：5.1、6.0、6.1 OC4J(Oracle)：10.1.3、11 JBoss：3.2、4.0、4.2 Tomcat：4.1、5.0、5.5、6.0 Jetty：4.2、5.1、6.1 Resin：2.1、3.0、3.1 GlassFish：v1、v2 1.2 控制反转（IOC）容器1.2.1 新的 bean 作用域Spring2.0：IoC 容器中只支持 singleton 和 prototype 两个不同的 bean 作用域。Spring2.5：还支持 request、session、global session 三个在 web 环境下使用的 bean 作用域，且提供了hooks，可以让用户创建自己的作用域。 1.2.2 更简单的 XML 配置Spring2.5 对 Spring2.0 的 DTD 进行了更新，spring-beans-2.0.dtd 可在发布包下的 dist/resources 下找到。12&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt; 1.2.3 可扩展的 XML 编写作为一个应用程序开发人员或第三方框架或产品的供应商，开发自定义标签，供其他开发人员把这些标签嵌入到自己的Spring配置文件里。 1.2.4 Annotation（注解）驱动配置Spring 2.0 引入了一些用于配置的 annotation, 包括 @Transactional, @Required, @PersistenceContext /@PersistenceUnit。Spring 2.5 引入了用于配置的完整的 Annotation 集合: @Autowired，以及对 JSR-250 注解 @Resource, @PostConstruct, @PreDestroy 的支持。 1.2.5 在 classpath 中自动搜索组件组件类会注解为 stereotype: @Component, @Repository, @Service, @Controller，取决于程序的上下文配置，这些组件会被自动搜索到，并且转变为 Spring bean 定义，而不需要为每个类都进行明确的配置。 1.3 面向切面编程（AOP）1.3.1 更加简单的 AOP XML 配置1.3.2 对 @AspectJ 切面的支持1.3.3 对 bean 命名 pointcut 的支持1.3.4 对 AspectJ 装载时织入的支持1.4 中间层1.4.1 在XML里更为简单的声明性事务配置Spring 2.5 支持方便的注解驱动的事务管理，通过 context:load-time-weaver 和 tx:annotation-driven mode=”aspectj” 的联合使用进行事务管理。 1.4.2 对 Websphere 事务管理的完整支持要自动探测底层的 JTA 事务平台，可以使用 Spring 2.5 的新 tx:jta-transaction-manager 配置元素。它会自动探测 BEA WebLogic 和 IBM WebSphere，注册正确的 PlatformTransactionManager。 1.4.3 JPASpring 2.5 对 OpenJPA 的支持升级到了 OpenJPA 1.0，支持 savepoint 这样的高级特性。 1.4.4 异步的JMS在 Spring 2.0 之前，Spring 的 JMS 的作用局限于发送消息和同步接收消息。Spring 2.0 提供对异步消息接收的完整支持。在 Spring 2.5 中， JCA 风格的异步消息监听器设置也通过 GenericMessageEndpointManager 工具得到了支持。 1.4.5 JDBC引入了新类，Spring 2.5 扩充了 SimpleJdbcTemplate 的功能，引入了 SimpleJdbcCall和 SimpleJdbcInsert 操作对象。 1.5 Web 层1.5.1 Spring MVC 合理的默认值1.5.2 Portlet 框架1.5.3 基于 Annotation 的控制器1.5.4 Spring MVC 的表单标签库1.5.5 对 Tiles 2，JSF 1.2，JAX-WS 支持2. spring 3.x 的新特性2.1 spring 3.02.1.1 Spring3.0 以后分成多个 jar 包 org.springframework.aop， 包含在应用中使用Spring的AOP特性时所需的类。 org.springframework.asm，Spring独立的asm程序，Spring2.5.6的时候需要 asm.jar 包，3.0开始提供自己独立的asm.jar org.springframework.aspects，提供对AspectJ的支持，以方便的将面向切面的功能集成进IDE中，比如Eclipse AJDT. org.springframework.beans，所有应用都要用到，它包含访问配置文件，创建和管理Bean以及进行反转共控制和依赖注入操作时所需的类 org.springframework.context，为 Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext 特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如 Velocity、 FreeMarker、 JasperReports 集成的类， 以及校验 Validation 方面的相关类。 org.springframework.context.support，包含支持缓存Cache（ehcache）JCA、JMX、邮件服务（Java Mail、Mail）COS、任务计划Scheduling（Timer、Quartz）方面的类。 org.springframework.core，包含 Spring 框架基本的核心工具类，Spring 其它组件要都要使用到这个包里的 类，是其它组件的基本核心。 org.springframework.expression，包含Spring 表达式语言相关的类，应用使用到SpEL时需要添加这个jar包。 org.springframework.instrument.tomcat，Spring3.0对Tomcat的连接池的集成。 org.springframework.instrument，Spring3.0 对服务器的代理接口。 org.springframework.jdbc，包含对 Spring 对 JDBC 数据访问进行封装的所有类。 org.springframework.jms，提供了对JMS1.0.2/1.1 的支持类。 org.springframework.orm，包含Spring对DAO特性集进行了扩展，使其支持iBATIS、JDO、OJB、TopLink，因+ 为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含 spring-dao.jar包。 org.springframework.oxm，Spring 对 Object/XMl 的映射支持,可以让Java与XML之间来回切换。 org.springframework.test，对Junit等测试框架的简单封装。 org.springframework.transaction，为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 org.springframework.web，包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 org.springframework.web.portlet，对SpringMVC的增强，包含SpringMVC相关的类 org.springframework.web.servlet，对J2EE6.0的Servlet3.0的支持。 org.springframework.web.struts，对Struts框架支持，可以更方便更容易的集成Struts框架。 2.1.2 新增特性 Spring 表达式语言 增强的 IOC 和基于 java 的 Bean 元数据 通用类型转换系统和字段格式 来自于 Srping Web Services 项目的对象和 XML 之间的映射 增强的 REST 支持 @MVC additions （Spring的 MVC 注解增强） 声明式模型验证 提前对 JEE6 的支持 嵌入式数据库的支持 2.1.3 基于 Java 5 的核心API的更新 BeanFactory接口尽可能的返回明确的实例： T getBean(Class requiredType) getBean(String name, Class requiredType) Map getBeansOfType(Class type) Spring 的 TaskExecutor 继承 java.util.concurrent.Executor 接口 扩展的子接口 AsyncTaskExecutor 支持标准的具有返回结果 Futures 的 Callables 基于 Java5 的 API 和 SPI 转换器 无状态的 ConversionService 和 Converters 取代标准的 JDK PropertyEditors 类型化的 ApplicationListener 2.1.4 Spring 表达式语言（简称SpEL）SpEL 使得 java 具有动态语言的风格，可以在运行时获取表达式的值。依赖注入时可以使用 SpEL 表达式语言, 不再只是原来简单的属性文件变量(xml)。示例： xml 配置： 123456&lt;bean class="mycompany.RewardsTestDatabase"&gt; &lt;property name="databaseName" value="#&#123;systemProperties.databaseName&#125;"/&gt; &lt;property name="keyGenerator" value="#&#123;strategyBean.databaseKeyGenerator&#125;"/&gt;&lt;/bean&gt; java 代码： 12345678@Repositorypublic class RewardsTestDatabase &#123; @Value("#&#123;systemProperties.databaseName&#125;") public void setDatabaseName(String dbName) &#123; ... &#125; @Value("#&#123;strategyBean.databaseKeyGenerator&#125;") public void setKeyGenerator(KeyGenerator kg) &#123; ... &#125;&#125; 2.1.5 增强的 IOC 和基于 java 的 bean 配置更多的注解的支持：@Configuration，@Bean，@DependsOn， @Primary，@Lazy，@Import，@ImportResource，@Value示例： xml 配置： 123&lt;context:component-scan base-package="org.example.config"/&gt;&lt;util:properties id="jdbcProperties" location="classpath:org/example/config/jdbc.properties"/&gt; 也可以使用如下代码来代替 xml 的配置： 12ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); FooService fooService = ctx.getBean(FooService.class); java 代码： 12345678910111213141516171819202122232425262728package org.example.config;...@Configurationpublic class AppConfig &#123; private @Value("#&#123;jdbcProperties.url&#125;") String jdbcUrl; private @Value("#&#123;jdbcProperties.username&#125;") String username; private @Value("#&#123;jdbcProperties.password&#125;") String password; @Bean public FooService fooService() &#123; return new FooServiceImpl(fooRepository()); &#125; @Bean public FooRepository fooRepository() &#123; return new HibernateFooRepository(sessionFactory()); &#125; @Bean public SessionFactory sessionFactory() &#123; // wire up a session factory AnnotationSessionFactoryBean asFactoryBean = new AnnotationSessionFactoryBean(); asFactoryBean.setDataSource(dataSource()); // additional config return asFactoryBean.getObject(); &#125; @Bean public DataSource dataSource() &#123; return new DriverManagerDataSource(jdbcUrl, username, password); &#125;&#125; 2.1.6 通用类型转换系统和字段格式化系统Spring3.0 加入了一个通用的类型转换系统，它被 SpEL 用作类型转换，并且可能被一个 Spring 容器使用，用于当绑定 bean 的属性值时进行类型转换。此外还增加了一个字段格式化系统，它提供了更简单且强大的功能以替代在客户端环境下的 Javabean 的 PropertyEidtors。 2.1.7 声明式模型验证支持 JSR303，使用 Hibernate Validator 作为默认实现：12345678public class Person &#123; @NotNull @Max(64) private String name; @Min(0) private int age; &#125; 2.2 spring 3.12.2.1 新增特性 Cache 抽象 Bean 定义配置文件 Environment 抽象 PropertySource 抽象 注解代替 xml 配置 对 Hibernate 4.x 的支持 TestContext 框架对 @Configuration 和 Bean 定义配置文件 的支持 更为简洁的构造函数注入 c: namespace 非标准 setter 类的注入 Servlet 3 code-based configuration of Servlet Container 的支持 Servlet 3 MultipartResolver 的支持 改善了 O/R 映射支持，允许无persistence.xml的JPA包扫描 可以在 controller 中，使用 annotation 临时指定特殊的 Mapping 或者 ExceptionHandler，而且整个体系更加灵活和可扩展。 2.3 spring 3.22.3.1 新增特性 支持基于Servlet 3的异步请求处理 Spring MVC Test框架 内容协商（Content Negotiation）改进。ContentNeogtiationStrategy 现在可以根据传入请求确定请求的媒体类型。可用的实现是基于文件扩展名、查询参数、“Accept”头或者一个固定的内容类型。 @ControllerAdvice 矩阵变量（Matrix Variables），增加了 @MatrixVariable 用于从请求URI中提取矩阵变量。 增加了一个抽象基础类用于支持基于代码的Servlet 3+容器初始化。 ResponseEntityExceptionHandler，用于处理异常消息的转换，和 DefaultHandlerExceptionResolver 的区别在于，这个类返回 ModelAndView。 RestTemplate 和 @RequestBody 的参数支持泛型。 支持Jackson JSON 2 支持Tiles 3 改进 @RequestBody。@RequestBody 和 @RequestPart 的参数现在可以跟随Error参数，使它可以在 @RequestMapping 方法中处理验证的错误，@RequestBody 现在有一个 required 属性。 HTTP PATCH 方法。HTTP PATCH方法现在可用于@RequestMapping 拦截器（Interceptor）支持 URL patterns 在注入点（Injection Point）和Bean方法定义中使用元注解 初步支持JCache 0.5 @DateTimeFormat不再依赖Joda Time 全局日期时间格式化 新的测试特性 并发性的微调 基于Gradle的构建系统，并迁移到GitHub 支持Java SE 7和OpenJDK 7 3. spring 4.x 的新特性3.1 spring 4.03.1.1 新增特性 删除了被丢弃的包和方法 Java 8 的支持，最低需要 Java 6 使用 Java EE 6 或以上的版本来作为基线，同时包含了相关的 JPA2.0 和 Servlet3.0 的规范 使用 Groovy 的 DSL（DomainSpecific Languages）来定义 Bean 核心容器的改进 Spring 注入 Bean 的时候把泛型类型当成一种形式的限定符。使用 Spring DataRepository 可以方便的插入特定的实现：@Autowired Repository customerRepository。 使用 Spring 的元注解支持，可以开发自定义注解来公开源注解的特定属性。 当自动装配到 lists 和 arrays 时，Beans 可以被排序，支持 @Order 注解和 Ordered 接口两种方式。 @Lazy 注解可以用在注入点以及 @Bean 定义上。 引入 @Description 注解,开发人员可以使用基于Java 方式的配置。 根据条件筛选 Beans 的广义模型通过 @Conditional 注解加入。这和@Profile支持的类似，但是允许以编程式开发用户定义的策略。 基于 CGLIB 的代理类不在需要默认的构造方法。 框架支持管理时区。 常规 Web 改进 在 Spring MVC 应用中使用新的 @RestController 注解时，不再需要给 @RequestMapping 的方法添加 @ResponseBody 注解。 AsyncRestTemplate 类已被添加进来，当开发 REST 客户端时，允许非阻塞异步支持。 当开发 Spring MVC 应用时，Spring 现在提供了全面的时区支持 WebSocket, SockJS 和 STOMP 消息 测试改进，引入了几个用于单元测试和集成测试的新功能 几乎 spring-test 模块中所有的注解（例如：@ContextConfiguration、@WebAppConfiguration、@ContextHierarchy、@ActiveProfiles 等等)可以用作元注解来创建自定义的 composed annotations 并且可以减少测试套件的配置。 现在可以以编程方式解决 Bean 定义配置文件的激活。只需要实现一个自定义的 ActiveProfilesResolver，并且通过 @ActiveProfiles的resolver 属性注册。 新的 SocketUtils 类被引入到了 spring-core 模块。 3.2 spring 4.13.2.1 新增特性 核心部分基本上无变化，提供了 DirectFieldAccessor 用于直接字段访问、yaml 配置、SpEL 的字节码编译化、BackOff 退避算法的基本实现、Base64Utils、SmartInitializingSingleton等； 在任务调度和事件机制上加入了异常处理部分； cache 部分加入 jcache 的集成、类级别的 @CacheConfig 的支持、CacheResolver； mvc 部分提供了一些视图解析器的 mvc 标签实现简化配置、提供了 GroovyWebApplicationContext 用于 Groovy web 集成、提供了 Gson、protobuf 的 HttpMessageConverter、静态资源处理方面添加了 resolver和 transformer、提供了对 groovy-templates 模板的支持、JSONP 的支持、对 Jackson 的 @JsonView 的支持等； 提供了页面自动化测试框架 Spring MVC Test HtmlUnit； test 部分提供了更便利的 @sql 标签来执行测试脚本的初始化、MockRestServiceServer 对 AyncRestTemplate 支持、MockMvcConfigurer 来全局配置 MockMvc； 提供了对 Java 8 Optional 的支持（ObjectToOptionalConverter 实现；可以在MVC中如 @RequestParam 等注解的绑定）、从Spring 4.1起 Ehcache 支持需要 EhCache 2.5 或更高版本、兼容 Quartz 2.1.4、支持 javax.annotation.Priority（等价于@Order）、JMS API的增强、SpringJUnit4ClassRunner 需要 JUnit 4.9或更高版本支持。 参考资料：开涛的博客–Spring 4.1 新特性——综述BigZ的专栏–Spring 4.0 新功能和增强中文翻译 Spring Framework 4.x参考文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github 与 Hexo 搭建博客步骤（使用 Next 主题）]]></title>
      <url>%2F2016%2F11%2F11%2FGithub%E4%B8%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[1. 安装前的准备Hexo 是一个快速简单并且强大的博客框架，使用者可以使用 markdown 语法编写文章，然后通过 hexo 生成带有主题的静态文件，并上传到 github，生成的 html 文件可以在浏览器上访问。本安装教程是在 ubuntu 平台上进行的，其他平台请另寻他处。安装前 Hexo 前需要先安装 Node.js 和 Git，在后面会描述其安装过程。 2. 安装 Git使用如下命令安装 Git，在这之后可以先了解 git 简单命令的使用，推荐：廖雪峰的Git教程。 1$ sudo apt-get install git-core 3. 安装 Node.js我们可以使用 nvm 来安装 Node.js ，方法如下：1curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh 或1$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh 安装完 nvm 之后重启窗口安装 Node.js：1$ nvm install stable 如果不想使用命令安装可以直接下载 Node.js 的安装包安装。下载完 linux 下的压缩包后，将其复制到 /usr/local 目录下，并使用 tar -xvJf + 文件名，对压缩包进行解压，更改解压后的文件夹的权限为755。修改环境变量，使用 vim 修改 /etc/profile，在文件末尾添加两行：123# node.jsexport NODE=/usr/local/node-v6.9.1-linux-x64export PATH=$&#123;NODE&#125;/bin:$PATH 之后执行命令 source /etc/profile，使用 node -v 命令查看版本号。 4. 安装 Hexo使用 npm 安装 hexo：1234$ sudo apt-get install npm$ sudo apt-get update$ sudo apt-get install nodejs-legacy$ sudo npm install -g hexo-cli 经过一段时间的等待，会在终端显示如下树状结果，hexo 安装完毕。 当 hexo 安装完毕，使用如下命令初始化 hexo 目录并安装依赖，生成的目录在当前所在的目录之下。123$ hexo init &lt;folder&gt; # 初始化 hexo 并创建目录$ cd &lt;folder&gt; # 切换到目录之下$ npm install # 安装依赖包 hexo 常用命令：1234$ hexo g #完整命令为hexo generate，用于生成静态文件$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上$ hexo n #完整命令为hexo new，用于新建一篇文章 在本地开启博客，用浏览器访问 http://localhost:4000/：12$ hexo g$ hexo s 5. 注册 Github 并创建 repository到 Github 官网注册 Github 账号，登录进入个人主页选择 Repositories，再点击旁边的 NEW 按钮创建新的 repository，名字的格式必须为 name.github.io，例如：windows7lake.github.io。 6. hexo 的配置整个博客的配置文件，位于 hexo\_config.yml，通过它，我们可以对整个博客进行配置。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Lio's Blog # 网站即博客的标题subtitle: No pains no gains! # 博客的副标题description: No pains no gains, Believes oneself, Nothing impossible! # 博客的描述author: Lio Lin # 作者language: zh-CN # 语言timezone:# URL 设置自己的域名## If your site is put in a subdirectory,## set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # 新创建的文章的默认文件名default_layout: post titlecase: false # 将标题转换为标题大小写external_link: true # 在新的标签中打开外部连接filename_case: 0 # 0 为默认; 1 为小写; 2 为大写render_drafts: false # 是否显示草稿post_asset_folder: falserelative_link: false # 是否创建相对于根文件夹的链接future: truehighlight: # 代码块设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示的文章数，0 表示不分页pagination_dir: page # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 主题名# Deployment 部署到 github 的配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/windows7lake/windows7lake.github.io branch: master 使用如下命令克隆 Next 主题到我们的本地博客之下：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 主题的配置文件，位于 hexo\theme\主题名\_config.yml，对主题的设置。这里对主题的配置可以参考 NexT 官网。 7. 将本地 Hexo 发布到 Github在本地创建 ssh key：1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的 your_email@youremail.com 改为自己的邮箱，之后会要求确认路径和输入密码，一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。 回到 github，进入 Settings，选择 SSH and GPG Keys -&gt; New SSH Key，title 随便填，粘贴 key。为了验证是否成功，输入：1$ ssh -T git@github.com 如果是第一次的会提示是否 continue，输入 yes 就会看到：You’ve successfully authenticated， but GitHub does not provide shell access ，这就表示已成功连上 github。 接下来我们要做的就是把本地仓库传到 github 上去，在此之前还需要设置 username 和 email，因为 github 每次 commit 都会记录他们。12$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 发布本地博客内容到 Github，需切换到博客目录下，执行如下两条命令，执行如下的第二个命令，可能会要你输入用户名和密码，皆为注册 Github 时的数据，输入密码是不显示任何东西的，输入完毕回车即可。12$ hexo g$ hexo d 如果输入 hexo d 后遇到 ERROR Deployer not found: Git，则使用命令 npm install hexo-deployer-git –save 即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F11%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
