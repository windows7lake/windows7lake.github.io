<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MyBatis 与 Spring 以及 Spring MVC 的整合]]></title>
      <url>%2F2017%2F01%2F14%2FMyBatis%20%E4%B8%8E%20Spring%20%E4%BB%A5%E5%8F%8A%20Spring%20MVC%20%E7%9A%84%E6%95%B4%E5%90%88%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis 基于 Web 应用的使用]]></title>
      <url>%2F2017%2F01%2F13%2FMybatis%20%E5%9F%BA%E4%BA%8E%20Web%20%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[简介引用 MyBatis 官网的介绍： MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 对于不同的人有不同的喜好，有些喜欢使用 xml 配置文件，有些则喜欢基于注解的方式，这个因人而异，使用者可以根据实际情况和个人喜好选择。 MyBatis 是一个简单易学的 ORM 框架，适合初学者入门 Java ORM 框架。ORM 是 Object Relation Mapping 的缩写（中文翻译：对象关系映射）。ORM 的作用是在关系型数据库和业务实体对象（POJO）之间作一个映射，我们在进行具体的业务操作的时候，就不需要再去和复杂的 SQL 语句打交道，只需简单的操作对象的属性和方法。 ORM 的优点： 剔除拼接 SQL 语句带来的麻烦以及易出错的问题。 剔除传统 JDBC 代码调用中重复性的代码，使数据库的配置更加简单化。 剔除 JDBC 返回的结果转换成领域模型的 Java 对象的麻烦，直接返回映射为 Java 对象的结果。 开发环境使用语言：Java（jdk1.8，下载地址：JavaSE Development Kit 8）IDE：Eclipse（Neon，下载地址：Eclipse Neon）项目构建工具：Maven数据库：Mysql（下载地址：MySQL Community Server） 主要类的认识（引用自官网）SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。 使用 Maven 搭建 Web 项目这里参考之前的文章：Eclipse 使用 Maven 构建 Web 项目 项目结构搭建完成的项目目录如下图所示： 在 pom.xml 中添加依赖123456789101112131415161718192021222324&lt;!-- mybatis 包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql驱动包 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单元测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 数据库准备schema.sql12345678910111213CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `book` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `title` VARCHAR(50) NOT NULL, `userid` INT(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; data.sql123456INSERT INTO `user` (`name`, `address`) VALUES ('Leo', 'GuangDong HuiZhou');INSERT INTO `user` (`name`, `address`) VALUES ('Dan', 'GuangDong ShanTou');INSERT INTO `book` (`title`, `userid`) VALUES ('C++', '1');INSERT INTO `book` (`title`, `userid`) VALUES ('Java', '1');INSERT INTO `book` (`title`, `userid`) VALUES ('Python', '1'); POJO 类User.java1234567891011121314151617181920212223242526272829303132package com.lake.model;public class User &#123; private int id; private String name; private String address; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; MyBatis 的配置文件在 resources 目录下建立 mybatis.xml 文件，其中定义了 Java 类所对应的别名、数据源和 mapper 文件的位置：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias alias="User" type="com.lake.model.User" /&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/lake/mapper/UserMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 其它的 XML 映射配置文件可参见官网。 定义 Mapper 接口定义 Mapper 的 Java 接口，用来访问数据库的接口，其中包括数据库操作的增删查改：12345678910111213package com.lake.mapper;import java.util.List;import com.lake.model.User;public interface UserMapper &#123; public User selectUserByID(int id); public List&lt;User&gt; selectUsersByName(String name); public void addUser(User user); public void updateUser(User user); public void deleteUser(int id);&#125; 使用 XML 定义 Mapper根据已实现的 Mapper 接口，我们需要通过 XML 来给出 Mapper 的实现，通常将 xxxMapper.xml（UserMapper） 文件放在 resources 目录下对应于 Mapper 接口的 com/lake/mapper/ 目录中。12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.lake.mapper.UserMapper"&gt; &lt;select id="selectUserByID" parameterType="int" resultType="User"&gt; select * from `user` where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 为了返回list 类型而定义的returnMap --&gt; &lt;resultMap type="User" id="resultListUser"&gt; &lt;id column="id" property="id" /&gt; &lt;result column="name" property="name" /&gt; &lt;result column="address" property="address" /&gt; &lt;/resultMap&gt; &lt;!-- 返回list 的select 语句，注意 resultMap 的值是指向前面定义好的 --&gt; &lt;select id="selectUsersByName" parameterType="string" resultMap="resultListUser"&gt; select * from user where name like #&#123;name&#125; &lt;/select&gt; &lt;!-- useGeneratedKeys为true时，表示自动获取数据库生成的主键值；keyProperty="id"表示将获取的主键值主要到User的属性id中 --&gt; &lt;insert id="addUser" parameterType="User" useGeneratedKeys="true" keyProperty="id"&gt; insert into user (name, address) values (#&#123;name&#125;, #&#123;address&#125;) &lt;/insert&gt; &lt;update id="updateUser" parameterType="User"&gt; update user set name=#&#123;name&#125;, address=#&#123;address&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteUser" parameterType="int"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; Mapper XML 文件更加详细的配置信息，参考官网的 Mapper XML 文件版块 关联数据一个用户可以拥有多本书，所以是一对多的关系。 创建 Book.java 类：1234567891011121314151617181920212223242526272829303132package com.lake.model;public class Book &#123; private int id; private String title; private User user; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 定义 Book 的 mapper 接口12345678package com.lake.mapper;import java.util.List;import com.lake.model.Book;public interface BookMapper &#123; public List&lt;Book&gt; getUserBooks(int id);&#125; 实现 Mapper 接口的 XML123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.lake.mapper.BookMapper"&gt; &lt;!-- User 联合 Book 进行查询方法之一的配置 (多对一的方式) --&gt; &lt;resultMap id="resultUserBookList" type="Book"&gt; &lt;id property="id" column="bid" /&gt; &lt;result property="title" column="title" /&gt; &lt;association property="user" javaType="User"&gt; &lt;id property="id" column="id" /&gt; &lt;result property="name" column="name" /&gt; &lt;result property="address" column="address" /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="getUserBooks" parameterType="int" resultMap="resultUserBookList"&gt; select user.id, user.name, user.address, book.id, book.title from user, book where book.userid=#&#123;id&#125; and user.id=book.userid &lt;/select&gt;&lt;/mapper&gt; &lt;association&gt; 的更多用法具体可到官网的自动映射模块查询。 接口测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.lake.test;import java.io.Reader;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.lake.mapper.UserMapper;import com.lake.model.User;public class Test &#123; private static SqlSessionFactory sqlSessionFactory; private static Reader reader; static &#123; try &#123; reader = Resources.getResourceAsReader("mybatis.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; public static SqlSessionFactory getSession() &#123; return sqlSessionFactory; &#125; /** * 获取用户列表 */ public void getUserList(String name) &#123; SqlSession session = sqlSessionFactory.openSession(); try &#123; UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = userMapper.selectUsersByName(name); for (User user : users) &#123; System.out.println(user.getId() + "--" + user.getName() + "--" + user.getAddress()); &#125; &#125; finally &#123; session.close(); &#125; &#125; /** * 增加用户信息，且必须提交事务，否则不会写入到数据库. */ public void addUser() &#123; User user = new User(); user.setName("Lake"); user.setAddress("GuangDong HuiZhou"); SqlSession session = sqlSessionFactory.openSession(); try &#123; UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.addUser(user); session.commit(); &#125; finally &#123; session.close(); &#125; &#125; /** * 更新用户信息 */ public void updateUser() &#123; SqlSession session = sqlSessionFactory.openSession(); try &#123; UserMapper userMapper = session.getMapper(UserMapper.class); User user = userMapper.selectUserByID(1); user.setAddress("GuangDong ChaoZhou"); userMapper.updateUser(user); session.commit(); &#125; finally &#123; session.close(); &#125; &#125; /** * 删除用户信息，删除一定要 commit. */ public void deleteUser(int id) &#123; SqlSession session = sqlSessionFactory.openSession(); try &#123; UserMapper userMapper = session.getMapper(UserMapper.class); userMapper.deleteUser(id); session.commit(); &#125; finally &#123; session.close(); &#125; &#125; /** * 返回关联的 Book 列表 */ public void getUserBooks(int userid) &#123; SqlSession session = sqlSessionFactory.openSession(); try &#123; BookMapper bookMapper = session.getMapper(BookMapper.class); List&lt;Book&gt; books = bookMapper.getUserBooks(userid); System.out.println(books.size()); for (Book book : books) &#123; System.out.println(book.getTitle() + " --- " + book.getUser().getName() + " --- " + book.getUser().getAddress()); &#125; &#125; finally &#123; session.close(); &#125; &#125; public static void main(String[] args) &#123; Test testUser = new Test(); testUser.addUser(); testUser.getUserList("%"); testUser.updateUser(); testUser.getUserList("%"); testUser.deleteUser(1); testUser.getUserList("%"); &#125;&#125; 输出结果1234567891011121--Leo--GuangDong HuiZhou2--Dan--GuangDong ShanTou3--Lake--GuangDong HuiZhou1--Leo--GuangDong ChaoZhou2--Dan--GuangDong ShanTou3--Lake--GuangDong HuiZhou2--Dan--GuangDong ShanTou3--Lake--GuangDong HuiZhouC++ --- Leo --- GuangDong ChaoZhouJava --- Leo --- GuangDong ChaoZhouPython --- Leo --- GuangDong ChaoZhou]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 grub 引导 linux 系统]]></title>
      <url>%2F2016%2F12%2F22%2F%E4%BD%BF%E7%94%A8%20grub%20%E5%BC%95%E5%AF%BC%20linux%20%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2016%2F12%2F22%2Fapache%2F</url>
      <content type="text"><![CDATA[commons-lang包中对我们有用的类主要有: StringUtils 该类主要提供对字符串的操作,对null是安全的,主要提供了字符串查找,替换,分割,去空白,去掉非法字符等等操作 ObjectUtils 主要是对null进行安全处理,可以设置为null时的默认返回值,比较相等时是调用对象的equals方法,因此需要对对象进行方法进行覆盖 SystemUtils 主要获取一些系统属性,例如工作目录等等 DateUtils/CalendarUtils 主要提供了对日期的操作,包括日期加减,日期格式化,日期比较,一定时间范围内日期的迭代等等 StopWatch 提供秒表的计时,暂停等功能 EqualsBuilder/HashCodeBuilder提供了方便的方法来覆盖equals() 和hashCode()方法 以Range结尾的类主要提供一些范围的操作,包括判断某些字符,数字等是否在这个范围以内 ArrayUtils 提供了数组的复制,查找,获取子数组,反转等功能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十八）—— Eclipse 使用 Maven 构建 Web 项目]]></title>
      <url>%2F2016%2F12%2F03%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%20Eclipse%20%E4%BD%BF%E7%94%A8%20Maven%20%E6%9E%84%E5%BB%BA%20Web%20%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[安装 Maven 插件使用 Maven 构建项目，当然需要先安装 Maven 插件。如果下载的是新版的 eclipse，一般都已经包含了 maven 插件，但如果没有 maven 插件，则需要手动安装。打开 Help –&gt; Install New Software，然后输入 HTTP 地址来安装（http://download.eclipse.org ），下载相应的版本。打开 Window –&gt; Preferences，检查 maven 插件是否安装成功： 建立 Maven 项目建立 Maven Project选择 File -&gt; New -&gt; Other 进入 New 窗口，选择 Maven -&gt; Maven Project，点击 Next。 选择项目路径这里可以选择自己所想要存储的项目路径，也可以选择默认的工作空间。 选择项目类型在 Artifact Id 处选择 maven-archetype-webapp。 指定项目参数输入 Group Id 和 Artifact Id 以及 Package，点击 Finish 完成 Maven 项目搭建。Group Id 通常写主项目名称，Artifact Id 为子项目名称，如 Spring 中，Group Id：org.springframework，Artifact Id：spring-core，Package 为项目中的包，可以使用默认的，也可以自己新建包。 建立完成在项目完成之前，这里会先从远程客户端下载所需要的包内容，所以会有进度条显示正在下载。如果没有翻墙，下载速度会非常慢，但是不着急的话可以让它慢慢下载，也可以下载别人打包好的 maven 包，放置在默认的家目录下的 .m2 文件下。下载完 maven 所需的包之后，可以看到如下信息：Maven 建立的项目完成后，其文件结果如下所示： 添加 Tomcat 库添加 Tomcat 服务器在建立完项目后，项目会报错 The superclass &quot;javax.servlet.http.HttpServlet&quot; was not found on the Java Build Path，这是没有导入 Tomcat 库的原因。切换到 Servers 下添加 Tomcat 服务器，打开 Window -&gt; Show View -&gt; Servers，点击 No servers are avaliable ...。在 New Server 窗口下选择 Apache -&gt; Tomcat v8.0 Server，这里选择自己的 tomcat 版本，点击 Next。点击 Browse 选择 tomcat 所在的根目录，并选择自己所使用的 JRE 环境，点击 Finish 完成，这是会生成一个 Servers 文件夹。 添加 Tomcat Libraries右键项目选择 Build Path -&gt; Configure Build Path，跳转到 Properties for maven 页面，选择 Libraries，点击 Add Library。在 Add Library 页面选择 Server Runtime，点击 Next，选择刚才添加的服务器，点击 Finish。上面的步骤之后，还可以点击 JRE System Library 选择自己想要的 jdk 版本，这里选择 1.8 版本。 配置 Maven 项目Source 文件夹在 Java Resources 需要 src/main/java，src/main/resources，src/test/java，src/test/resources，如果没有的则右击根目录 New -&gt; Source Folder 建立所需的文件夹。 更改 class 路径右键项目选择 Properties -&gt; Java Build Path -&gt; Source，为每个文件夹选择对应的输出文件夹。双击每个文件夹的 Output folder，选择路径： src/main/java，src/main/resources，选择 target/classes src/test/java，src/test/resources，选择 target/test-classes 选上 Allow output folders for source folders。 转换为 Dynamic Web 项目修改设置配置 Dynamic Web打开 Window -&gt; Show View -&gt; Navigator，在根目录下选择 .setting 文件夹，修改以下文件内容。修改 org.eclipse.jdt.core.prefs 文件，将版本号改为所选的 JRE 版本，这里为 1.8：12345678eclipse.preferences.version=1org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabledorg.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8org.eclipse.jdt.core.compiler.compliance=1.8org.eclipse.jdt.core.compiler.problem.assertIdentifier=errororg.eclipse.jdt.core.compiler.problem.enumIdentifier=errororg.eclipse.jdt.core.compiler.problem.forbiddenReference=warningorg.eclipse.jdt.core.compiler.source=1.8 将 org.eclipse.wst.common.component 文件在的 project-version 也改为 1.8.0：1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project-modules id="moduleCoreId" project-version="1.8.0"&gt; &lt;wb-module deploy-name="maven"&gt; &lt;wb-resource deploy-path="/" source-path="/target/m2e-wtp/web-resources" /&gt; &lt;wb-resource deploy-path="/" source-path="/src/main/webapp" tag="defaultRootSource" /&gt; &lt;wb-resource deploy-path="/WEB-INF/classes" source-path="/src/main/java" /&gt; &lt;wb-resource deploy-path="/WEB-INF/classes" source-path="/src/main/resources" /&gt; &lt;wb-resource deploy-path="/WEB-INF/classes" source-path="/src/test/java" /&gt; &lt;wb-resource deploy-path="/WEB-INF/classes" source-path="/src/test/resources" /&gt; &lt;property name="context-root" value="maven" /&gt; &lt;property name="java-output-path" value="/maven/target/classes" /&gt; &lt;/wb-module&gt;&lt;/project-modules&gt; 修改 org.eclipse.wst.common.project.facet.core.xml 文件如下：1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;faceted-project&gt; &lt;fixed facet="wst.jsdt.web" /&gt; &lt;installed facet="java" version="1.5" /&gt;&lt;!-- JDK 的版本 --&gt; &lt;installed facet="jst.web" version="2.3" /&gt;&lt;!-- Dynamic Web Moduel 的版本 --&gt; &lt;installed facet="wst.jsdt.web" version="1.0" /&gt;&lt;/faceted-project&gt; 修改为1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;faceted-project&gt; &lt;fixed facet="wst.jsdt.web" /&gt; &lt;installed facet="java" version="1.8" /&gt;&lt;!-- JDK 的版本 --&gt; &lt;installed facet="jst.web" version="3.1" /&gt;&lt;!-- Dynamic Web Moduel 的版本 --&gt; &lt;installed facet="wst.jsdt.web" version="1.0" /&gt;&lt;/faceted-project&gt; 查看配置结果回到 Project Explorer，右键选择 Properties -&gt; Project Facets，可查看使用的 Dynamic Web Module 和 Java 的版本。 设置部署程序集在 Properties 窗口会关闭，选择 Deployment Assembly，点击进去后，如图：此处列表是，部署项目时，文件发布的路径，由于正式部署时不需要测试的文件内容，所以删除 test 两项。 向 Maven 项目中添加 jar 包pom.xml 的配置Maven 可以管理项目依赖的 jar 包，通过 groupId， artifactId 以及 version 可以唯一确定一个 jar 包。这样可以防止老式 Web 项目中 WEB-INF/lib 下 jar 包不一致的问题，并且 Maven 还会自动下载添加进来的 jar 包所依赖的 jar 包。在 pom.xml 中添加所需要的 jar 包如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lake&lt;/groupId&gt; &lt;artifactId&gt;DebitSystem&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;DebitSystem Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- hibernate版本号 --&gt; &lt;hibernate.version&gt;5.1.3.Final&lt;/hibernate.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- hibernate --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;DebitSystem&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 设置 jar 包的 scopescope 有以下几种取值： compile，缺省值，适用于所有阶段，会随着项目一起发布。 provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如 servlet.jar。 runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test，只在测试时使用，用于编译和运行测试代码，不会随项目发布。 system，类似 provided，需要显式提供包含依赖的jar，Maven 不会在 Repository 中查找它。 参考资料：使用Eclipse构建Maven的SpringMVC项目]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十五）—— Spring JDBC 访问数据库之 SimpleJdbc]]></title>
      <url>%2F2016%2F11%2F27%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20Spring%20JDBC%20%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%20SimpleJdbc%2F</url>
      <content type="text"><![CDATA[使用 SimpleJdbcInsert 插入数据从具有最少配置选项的 SimpleJdbcInsert 类开始，在数据访问层的初始化方法中实例化 SimpleJdbcInsert。对于下面的示例，初始化方法是 setDataSource 方法，不需要继承 SimpleJdbcInsert 类，只需创建一个新实例并使用 withTableName 方法设置表名。12345678910111213141516171819public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; private SimpleJdbcInsert insertActor; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor"); &#125; public void add(Actor actor) &#123; Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3); parameters.put("id", actor.getId()); parameters.put("first_name", actor.getFirstName()); parameters.put("last_name", actor.getLastName()); insertActor.execute(parameters); &#125; // ... additional methods&#125; 这里使用的 execute 方法将一个简单的 java.utils.Map 作为其唯一的参数，需要注意的是，用于 Map 的键必须匹配数据库中定义的表的列名，因为我们需要读取元数据以构造实际的 insert 语句。 使用 SimpleJdbcInsert 检索自动生成的键此示例使用与前面相同的插入，但不是传递 id，而是检索自动生成的键并将其设置在新的 Actor 对象上。创建 SimpleJdbcInsert 时，除了指定表名称之外，还可以使用 usingGeneratedKeyColumns 方法指定生成的键列的名称。123456789101112131415161718192021public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; private SimpleJdbcInsert insertActor; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); this.insertActor = new SimpleJdbcInsert(dataSource) .withTableName("t_actor") .usingGeneratedKeyColumns("id"); &#125; public void add(Actor actor) &#123; Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2); parameters.put("first_name", actor.getFirstName()); parameters.put("last_name", actor.getLastName()); Number newId = insertActor.executeAndReturnKey(parameters); actor.setId(newId.longValue()); &#125; // ... additional methods&#125; 使用上述方法执行插入操作时，不用将 ID 添加到 Map 中，而是调用 executeAndReturnKey 方法，这将返回一个 java.lang.Number 对象，我们可以使用它创建在域类中使用的数值类型的实例。如果有多个自动生成的列，或者生成的值是非数字的，那么可以使用从 executeAndReturnKeyHolder 方法返回的 KeyHolder。 为 SimpleJdbcInsert 指定列使用 usingColumns 方法指定列：12345678910111213141516171819202122public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; private SimpleJdbcInsert insertActor; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); this.insertActor = new SimpleJdbcInsert(dataSource) .withTableName("t_actor") .usingColumns("first_name", "last_name") .usingGeneratedKeyColumns("id"); &#125; public void add(Actor actor) &#123; Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2); parameters.put("first_name", actor.getFirstName()); parameters.put("last_name", actor.getLastName()); Number newId = insertActor.executeAndReturnKey(parameters); actor.setId(newId.longValue()); &#125; // ... additional methods&#125; 使用 SqlParameterSource 提供参数值使用 Map 提供参数值不是最方便使用的类，Spring 提供了两个 SqlParameterSource 接口的实现。第一个是 BeanPropertySqlParameterSource，它将使用相应的 getter 方法提取 JavaBean 中的参数值。下面是例子：12345678910111213141516171819public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; private SimpleJdbcInsert insertActor; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); this.insertActor = new SimpleJdbcInsert(dataSource) .withTableName("t_actor") .usingGeneratedKeyColumns("id"); &#125; public void add(Actor actor) &#123; SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor); Number newId = insertActor.executeAndReturnKey(parameters); actor.setId(newId.longValue()); &#125; // ... additional methods&#125; 另一个是 MapSqlParameterSource（类似于Map），但提供了一个更方便的可以链接的 addValue 方法：123456789101112131415161718192021public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; private SimpleJdbcInsert insertActor; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); this.insertActor = new SimpleJdbcInsert(dataSource) .withTableName("t_actor") .usingGeneratedKeyColumns("id"); &#125; public void add(Actor actor) &#123; SqlParameterSource parameters = new MapSqlParameterSource() .addValue("first_name", actor.getFirstName()) .addValue("last_name", actor.getLastName()); Number newId = insertActor.executeAndReturnKey(parameters); actor.setId(newId.longValue()); &#125; // ... additional methods&#125; 使用 SimpleJdbcCall 调用存储过程SimpleJdbcCall 类利用数据库中的元数据来查找输入和输出参数的名称，因此可以不必显式地声明它们。如果希望执行此操作，或者如果参数（如 ARRAY 或 STRUCT）没有自动映射到 Java 类，那么可以声明参数。第一个例子显示了一个简单的过程，它只从 MySQL 数据库返回 VARCHAR 和 DATE 格式的标量值。示例过程读取指定的 actor 条目，并以 out 参数的形式返回 first_name，last_name 和 birth_date 列。12345678910CREATE PROCEDURE read_actor ( IN in_id INTEGER, OUT out_first_name VARCHAR(100), OUT out_last_name VARCHAR(100), OUT out_birth_date DATE)BEGIN SELECT first_name, last_name, birth_date INTO out_first_name, out_last_name, out_birth_date FROM t_actor where id = in_id;END; in_id 参数包含需要查找的 actor 的 id，out 参数返回表中读取的数据。 下面是使用上述存储过程的 SimpleJdbcCall 配置的示例，除了 DataSource 之外，唯一的配置选项是存储过程的名称。123456789101112131415161718192021222324public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; private SimpleJdbcCall procReadActor; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); this.procReadActor = new SimpleJdbcCall(dataSource) .withProcedureName("read_actor"); &#125; public Actor readActor(Long id) &#123; SqlParameterSource in = new MapSqlParameterSource() .addValue("in_id", id); Map out = procReadActor.execute(in); Actor actor = new Actor(); actor.setId(id); actor.setFirstName((String) out.get("out_first_name")); actor.setLastName((String) out.get("out_last_name")); actor.setBirthDate((Date) out.get("out_birth_date")); return actor; &#125; // ... additional methods&#125; execute 方法接受 IN 参数，并返回一个 Map，该 Map 包含由存储过程中指定的名称键入的任何输出参数。在这种情况下，它们是 out_first_name，out_last_name 和 out_birth_date。 存储在结果映射中的 out 参数的名称与数据库中的 out 参数名称相同，其可以在数据库之间变化。为了使代码更便于移植，应该做一个不区分大小写的查找，或者指示 Spring 使用 LinkedCaseInsensitiveMap。后者需要创建自己的 JdbcTemplate 并将 setResultsMapCaseInsensitive 属性设置为 true，然后将此定制的 JdbcTemplate 实例传递到 SimpleJdbcCall 的构造函数中。以下是此配置的示例：123456789101112public class JdbcActorDao implements ActorDao &#123; private SimpleJdbcCall procReadActor; public void setDataSource(DataSource dataSource) &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); jdbcTemplate.setResultsMapCaseInsensitive(true); this.procReadActor = new SimpleJdbcCall(jdbcTemplate) .withProcedureName("read_actor"); &#125; // ... additional methods&#125; 显式声明要用于 SimpleJdbcCall 的参数使用方法声明参数：1234567891011121314151617181920public class JdbcActorDao implements ActorDao &#123; private SimpleJdbcCall procReadActor; public void setDataSource(DataSource dataSource) &#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); jdbcTemplate.setResultsMapCaseInsensitive(true); this.procReadActor = new SimpleJdbcCall(jdbcTemplate) .withProcedureName("read_actor") .withoutProcedureColumnMetaDataAccess() .useInParameterNames("in_id") .declareParameters( new SqlParameter("in_id", Types.NUMERIC), new SqlOutParameter("out_first_name", Types.VARCHAR), new SqlOutParameter("out_last_name", Types.VARCHAR), new SqlOutParameter("out_birth_date", Types.DATE) ); &#125; // ... additional methods&#125; 使用 SimpleJdbcCall 调用存储过程函数调用存储函数的方式与调用存储过程几乎相同，除了需要提供的是函数名而不是过程名。使用 withFunctionName 方法传入要调用函数，并生成函数调用的相应字符串。executeFunction 用于执行函数，并返回函数返回值作为指定类型的对象，这意味着不必从结果映射中检索返回值。以下示例基于一个名为 get_actor_name 的存储函数，它返回一个 actor 的全名。如下是这个函数的 MySQL 源码：123456789CREATE FUNCTION get_actor_name (in_id INTEGER)RETURNS VARCHAR(200) READS SQL DATABEGIN DECLARE out_name VARCHAR(200); SELECT concat(first_name, ' ', last_name) INTO out_name FROM t_actor where id = in_id; RETURN out_name;END; 123456789101112131415161718192021public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; private SimpleJdbcCall funcGetActorName; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); jdbcTemplate.setResultsMapCaseInsensitive(true); this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate) .withFunctionName("get_actor_name"); &#125; public String getActorName(Long id) &#123; SqlParameterSource in = new MapSqlParameterSource() .addValue("in_id", id); String name = funcGetActorName.executeFunction(String.class, in); return name; &#125; // ... additional methods&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十四）—— Spring JDBC 访问数据库之控制数据库连接]]></title>
      <url>%2F2016%2F11%2F26%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20Spring%20JDBC%20%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[DataSourceSpring 通过 DataSource 获取数据库连接，DataSource 是 JDBC 规范的一部分，是一个通用连接工厂。它允许容器或框架从应用程序代码中隐藏连接池和事务管理问题。当使用 Spring 的 JDBC 层时，从 JNDI 获取数据源，或者使用第三方提供的连接池实现配置自己的数据源，最受欢迎的实现是 Apache Jakarta Commons DBCP 和 C3P0。通过获得与 DriverManagerDataSource 的连接来获取 JDBC 连接，指定 JDBC 驱动程序的完全限定类名，以便 DriverManager 可以加载驱动程序类，接着提供在 JDBC 驱动程序的 URL，然后提供用户名和密码以连接到数据库。 如下为在 Java 代码中配置 DriverManagerDataSource 的示例：12345DriverManagerDataSource dataSource = new DriverManagerDataSource();dataSource.setDriverClassName("org.hsqldb.jdbcDriver");dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");dataSource.setUsername("sa");dataSource.setPassword(""); 相关连的 XML 配置：12345678&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt;&lt;context:property-placeholder location="jdbc.properties"/&gt; DBCP 配置：12345678&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt;&lt;context:property-placeholder location="jdbc.properties"/&gt; C3P0 配置：12345678&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt;&lt;context:property-placeholder location="jdbc.properties"/&gt; DataSourceUtilsDataSourceUtils 类是一个便捷且强大的帮助类，它提供了从 JNDI 获取连接的静态方法，并在必要时关闭连接，它支持线程绑定连接，例如：DataSourceTransactionManager。 SmartDataSourceSmartDataSource 接口应由可以提供与关系数据库连接的类实现，它扩展了 DataSource 接口，允许使用它来查询在给定操作之后是否应该关闭连接。 AbstractDataSourceAbstractDataSource 是 Spring DataSource 实现的一个抽象基类，如果需要自定义 DataSource 实现，即可继承 AbstractDataSource 类。 SingleConnectionDataSourceSingleConnectionDataSource 类是 SmartDataSource（封装了每次使用后未关闭的单个连接） 接口的实现。它能够与简单的 JNDI 环境结合，轻松地在应用程序服务器之外测试代码，与 DriverManagerDataSource 相反，它一直重复使用同一个连接，避免过多创建物理连接。 DriverManagerDataSourceDriverManagerDataSource 类是标准 DataSource 接口的实现，它通过 bean 属性配置简单的 JDBC 驱动程序，并且每次都返回一个新的连接。 TransactionAwareDataSourceProxyTransactionAwareDataSourceProxy 是目标 DataSource 的代理，它包装目标 DataSource 以增强对 Spring 管理事务的认识。在这方面，它类似于由 Java EE 服务器提供的事务 JNDI DataSource。 DataSourceTransactionManagerDataSourceTransactionManager 类是单个 JDBC 数据源的 PlatformTransactionManager 实现。它将 JDBC 连接从指定的数据源绑定到当前正在执行的线程，从而潜在地允许每个数据源一个线程连接。需要应用程序代码来通过 DataSourceUtils.getConnection（DataSource） 而不是 Java EE 的标准 DataSource.getConnection 来检索 JDBC 连接。它抛出 unchecked 的 org.springframework.dao 异常，而不是 checked SQLExceptions。DataSourceTransactionManager 类支持自定义隔离级别，并且用于作为 JDBC 语句查询超时应用的超时。为了支持后者，应用程序代码必须对每个创建的语句使用 JdbcTemplate 或调用 DataSourceUtils.applyTransactionTimeout（..） 方法。 NativeJdbcExtractor使用 NativeJdbcExtractor 配置自己的 JdbcTemplate 或 OracleLobHandler 访问与标准 JDBC API 不同的供应商特定的 JDBC 方法。 初始化 DataSource使用 Spring XML 初始化数据库，提供一个指向 DataSource bean 的引用，在 spring-jdbc 命名空间中使用 initialize-database 标签：1234&lt;jdbc:initialize-database data-source="dataSource"&gt; &lt;jdbc:script location="classpath:com/foo/sql/db-schema.sql"/&gt; &lt;jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/&gt;&lt;/jdbc:initialize-database&gt; 然而，为了获得对现有数据的创建和删除的更多控制，XML 命名空间提供了一些附加选项。第一个是用于开启和关闭初始化的标志，这可以根据环境进行设置（例如，从系统属性或环境 bean 中提取布尔值），例如：123&lt;jdbc:initialize-database data-source="dataSource" enabled="#&#123;systemProperties.INITIALIZE_DATABASE&#125;"&gt; &lt;jdbc:script location="..."/&gt;&lt;/jdbc:initialize-database&gt; 第二个选项是更能容忍故障，可以控制初始化程序的能力来忽略执行 SQL 脚本产生的某一错误，例如：123&lt;jdbc:initialize-database data-source="dataSource" ignore-failures="DROPS"&gt; &lt;jdbc:script location="..."/&gt;&lt;/jdbc:initialize-database&gt; 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十三）—— Spring JDBC 访问数据库之 JdbcTemplate 及错误处理]]></title>
      <url>%2F2016%2F11%2F25%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20Spring%20JDBC%20%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%20JdbcTemplate%20%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[Spring JDBC 是 Spring 所提供的持久层技术，它主要目的是降低使用 JDBC API 的门槛，以一种更直接、更简洁的方式使用 JDBC API。在 Spring JDBC 里，只需要完成定义连接数据库的参数、指定 SQL 语句、声明参数及参数值这些必要的事，而将资源获取、Statement 创建、资源释放以及异常处理等繁杂而乏味的工作交给 Spring JDBC。 JdbcTemplateJdbcTemplate 是 JDBC 核心包中的主要类，它可以处理资源的创建和释放，帮助我们避免忘记关闭连接等类似错误。JdbcTemplate 类执行 SQL 查询，更新语句和存储过程调用，对 ResultSet 执行迭代和提取返回的参数值。它还能捕获 JDBC 异常，并将它们转换为 org.springframework.dao 包中定义的通用的、更丰富的异常层次结构。 Querying (SELECT)下面是一个获取关系中行数的简单查询：1int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class); 使用绑定变量的简单查询：12int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject( "select count(*) from t_actor where first_name = ?", Integer.class, "Joe"); 查询得到一个 String 变量：12String lastName = this.jdbcTemplate.queryForObject("select last_name from t_actor where id = ?", new Object[]&#123;1212L&#125;, String.class); 查询和填充单个域对象：1234567891011Actor actor = this.jdbcTemplate.queryForObject( "select first_name, last_name from t_actor where id = ?", new Object[]&#123;1212L&#125;, new RowMapper&lt;Actor&gt;() &#123; public Actor mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Actor actor = new Actor(); actor.setFirstName(rs.getString("first_name")); actor.setLastName(rs.getString("last_name")); return actor; &#125; &#125;); 查询和填充多个域对象：12345678910List&lt;Actor&gt; actors = this.jdbcTemplate.query( "select first_name, last_name from t_actor", new RowMapper&lt;Actor&gt;() &#123; public Actor mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Actor actor = new Actor(); actor.setFirstName(rs.getString("first_name")); actor.setLastName(rs.getString("last_name")); return actor; &#125; &#125;); Updating (INSERT/UPDATE/DELETE)使用 update(..) 方法执行插入、更新和删除操作，参数值通常由 var 参数或对象数组提供。123this.jdbcTemplate.update( "insert into t_actor (first_name, last_name) values (?, ?)", "Leonor", "Watling"); 123this.jdbcTemplate.update( "update t_actor set last_name = ? where id = ?", "Banjo", 5276L); 123this.jdbcTemplate.update( "delete from actor where id = ?", Long.valueOf(actorId)); Execute我们可以使用 execute（..） 方法执行任意的 SQL 语句，因此该方法通常用于 DDL（数据库定义语言）。1this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))"); 示例JdbcTemplate 类的实例为线程安全的，这意味着我们可以配置 JdbcTemplate 的单实例，并将此共享引用安全地注入到多个 DAO。使用 JdbcTemplate 类（以及相关的 NamedParameterJdbcTemplate 类）的一个常见做法是在 Spring 配置文件中配置一个 DataSource，然后将共享的 DataSource bean 依赖注入到 DAO 类中; JdbcTemplate 在 DataSource 的 setter 方法中创建。 DAO 部分如下示例：123456789public class JdbcCorporateEventDao implements CorporateEventDao &#123; private JdbcTemplate jdbcTemplate; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); &#125; // JDBC-backed implementations of the methods on the CorporateEventDao follow...&#125; 相关的 XML 配置如下：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;context:property-placeholder location="jdbc.properties"/&gt;&lt;/beans&gt; 上述的配置方法也可以使用显示配置的方法替代，显式配置的替代方法是对依赖注入使用组件扫描和注释支持 在这种情况下，使用 @Repository 注释类（这使它成为组件扫描的候选类），并使用 @Autowired 注释 DataSource 的 setter 方法。 DAO 部分如下示例：1234567891011@Repositorypublic class JdbcCorporateEventDao implements CorporateEventDao &#123; private JdbcTemplate jdbcTemplate; @Autowired public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); &#125; // JDBC-backed implementations of the methods on the CorporateEventDao follow...&#125; 相关的 XML 配置如下：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- Scans within the base package of the application for @Component classes to configure as beans --&gt; &lt;context:component-scan base-package="org.springframework.docs.test" /&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;context:property-placeholder location="jdbc.properties"/&gt;&lt;/beans&gt; NamedParameterJdbcTemplateNamedParameterJdbcTemplate 类增加了使用命名参数对 JDBC 语句进行编程的支持，而不是仅使用占位符（’？’）参数来对 JDBC 语句进行编程。NamedParameterJdbcTemplate 类封装了一个 JdbcTemplate，并委托给包装的 JdbcTemplate 来完成它的大部分工作。MapSqlParameterSource 实现类内部通过一个 Map 存储参数，可以通过 addValue(String paramName, Object value) 或 addValue(Map values) 添加参数，并通过参数名和 SQL 语句的命名参数匹配的方式绑定参数。1234567891011121314// some JDBC-backed DAO class...private NamedParameterJdbcTemplate namedParameterJdbcTemplate;public void setDataSource(DataSource dataSource) &#123; this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);&#125;public int countOfActorsByFirstName(String firstName) &#123; String sql = "select count(*) from T_ACTOR where first_name = :first_name"; SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName); // 还可以使用基于 Map 的格式，MapSqlParameterSource 只是对 Map 的简单实现 // Map&lt;String, String&gt; namedParameters = Collections.singletonMap("first_name", firstName); return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);&#125; 另一个 SqlParameterSource 实现类是 BeanPropertySqlParameterSource，这个类将一个 JavaBean 对象封装成一个参数源，以便通过 JavaBean 属性名和 SQL 语句中命名参数匹配的方式绑定参数。12345678910111213141516public class Actor &#123; private Long id; private String firstName; private String lastName; public String getFirstName() &#123; return this.firstName; &#125; public String getLastName() &#123; return this.lastName; &#125; public Long getId() &#123; return this.id; &#125; // setters omitted...&#125; 12345678910111213// some JDBC-backed DAO class...private NamedParameterJdbcTemplate namedParameterJdbcTemplate;public void setDataSource(DataSource dataSource) &#123; this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);&#125;public int countOfActors(Actor exampleActor) &#123; // notice how the named parameters match the properties of the above 'Actor' class String sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName"; SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor); return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);&#125; SQLExceptionTranslatorSQLExceptionTranslator 是一个接口类，可以在 SQLExceptions 和 Spring 的 org.springframework.dao.DataAccessException 之间进行转换。SQLErrorCodeSQLExceptionTranslator 是 SQLExceptionTranslator 的默认实现，此实现使用特定的供应商代码，它比 SQLState 实现更精确，此类由 SQLErrorCodesFactory 创建和填充，SQLErrorCodesFactory 是创建 SQLErrorCodes 的工厂类，且是基于名为 sql-error-codes.xml 的配置文件的内容创建的。 自定义 SQLErrorCodeSQLExceptionTranslator 类：12345678public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator &#123; protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) &#123; if (sqlex.getErrorCode() == -12345) &#123; return new DeadlockLoserDataAccessException(task, sqlex); &#125; return null; &#125;&#125; 在此示例中，特定错误代码 -12345 被转换，其他错误由默认转换器实现进行转换。要使用此自定义转换器，需要通过方法 setExceptionTranslator 将其传递给 JdbcTemplate，并将此 JdbcTemplate 用于需要此转换器的所有数据访问处理中。下面是如何使用自定义转换器的示例：123456789101112131415161718private JdbcTemplate jdbcTemplate;public void setDataSource(DataSource dataSource) &#123; // create a JdbcTemplate and set data source this.jdbcTemplate = new JdbcTemplate(); this.jdbcTemplate.setDataSource(dataSource); // create a custom translator and set the DataSource for the default translation lookup CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator(); tr.setDataSource(dataSource); this.jdbcTemplate.setExceptionTranslator(tr);&#125;public void updateShippingCharge(long orderId, long pct) &#123; // use the prepared JdbcTemplate for this update this.jdbcTemplate.update("update orders set shipping_charge = shipping_charge * ? / 100" + " where id = ?", pct, orderId);&#125; 更新数据库1234567891011121314import javax.sql.DataSource;import org.springframework.jdbc.core.JdbcTemplate;public class ExecuteAnUpdate &#123; private JdbcTemplate jdbcTemplate; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); &#125; public void setName(int id, String name) &#123; this.jdbcTemplate.update("update mytable set name = ? where id = ?", name, id); &#125;&#125; 返回自增键update() 方法支持检索由数据库生成的主键，该方法将 PreparedStatementCreator 作为其第一个参数，是指定所需的 insert 语句的方式；另一个参数是 KeyHolder，它包含更新成功返回时生成的密钥。123456789101112131415final String INSERT_SQL = "insert into my_test (name) values(?)";final String name = "Rob";KeyHolder keyHolder = new GeneratedKeyHolder();jdbcTemplate.update( new PreparedStatementCreator() &#123; public PreparedStatement createPreparedStatement(Connection connection) throws SQLException &#123; PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] &#123;"id"&#125;); ps.setString(1, name); return ps; &#125; &#125;, keyHolder);// keyHolder.getKey() now contains the generated key 批量操作如果需要一次性插入或更新多条记录，可以简单地通过多次调用 update() 方法完成任务，也可以使用 JDBCTemplate 批量数据更改的方法。一般后者的性能更好，因为更新的数据将被批量发送到数据库中，它减少了对数据库访问的次数。 使用 JdbcTemplate 进行批量操作使用 JdbcTemplate 批量操作需要实现指定接口 BatchPreparedStatementSetter 的两个方法，并将其实现作为 batchUpdate 方法的第二个参数，此方法的调用次数为 getBatchSize 方法中返回的次数。使用 getBatchSize 方法返回当前批处理的大小；使用 setValues 方法设置预准备语句的参数值。以下示例根据列表中的条目更新 actor 表，整个列表在本示例中用作批处理：1234567891011121314151617181920212223242526public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); &#125; public int[] batchUpdate(final List&lt;Actor&gt; actors) &#123; int[] updateCounts = jdbcTemplate.batchUpdate( "update t_actor set first_name = ?, last_name = ? where id = ?", new BatchPreparedStatementSetter() &#123; public void setValues(PreparedStatement ps, int i) throws SQLException &#123; ps.setString(1, actors.get(i).getFirstName()); ps.setString(2, actors.get(i).getLastName()); ps.setLong(3, actors.get(i).getId().longValue()); &#125; public int getBatchSize() &#123; return actors.size(); &#125; &#125;); return updateCounts; &#125; // ... additional methods&#125; 使用 List 进行批量操作JdbcTemplate 和 NamedParameterJdbcTemplate 都提供了批量更新的替代方法，不是实现特殊的批处理接口，而是将调用中的所有参数值作为 List 提供。namedParameterJdbcTemplate 提供了一个 SqlParameterSource 数组，批处理的每个成员都是一个条目，使用 SqlParameterSource.createBatch 方法可以创建此数组，其传入的参数为包含参数值的 JavaBeans 数组或 Maps 数组。 使用 NamedParameterJdbcTemplate 的批量更新：1234567891011121314151617public class JdbcActorDao implements ActorDao &#123; private NamedParameterTemplate namedParameterJdbcTemplate; public void setDataSource(DataSource dataSource) &#123; this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource); &#125; public int[] batchUpdate(final List&lt;Actor&gt; actors) &#123; SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(actors.toArray()); int[] updateCounts = namedParameterJdbcTemplate.batchUpdate( "update t_actor set first_name = :firstName, last_name = :lastName where id = :id", batch); return updateCounts; &#125; // ... additional methods&#125; 使用 JdbcTemplate 和占位符 “？” 的批量更新：123456789101112131415161718192021222324public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); &#125; public int[] batchUpdate(final List&lt;Actor&gt; actors) &#123; List&lt;Object[]&gt; batch = new ArrayList&lt;Object[]&gt;(); for (Actor actor : actors) &#123; Object[] values = new Object[] &#123; actor.getFirstName(), actor.getLastName(), actor.getId() &#125;; batch.add(values); &#125; int[] updateCounts = jdbcTemplate.batchUpdate( "update t_actor set first_name = ?, last_name = ? where id = ?", batch); return updateCounts; &#125; // ... additional methods&#125; 多批次的批量操作batchUpdate 方法的参数除了 SQL 语句之外，还有一个包含参数的对象集合和每个批次所需更新的数量，以及 ParameterizedPreparedStatementSetter（用于设置预准备语句的参数值）。框架在所提供的值上循环，并将更新调用分成指定大小的批处理。 如下是每批为 100 的批处理示例：123456789101112131415161718192021222324public class JdbcActorDao implements ActorDao &#123; private JdbcTemplate jdbcTemplate; public void setDataSource(DataSource dataSource) &#123; this.jdbcTemplate = new JdbcTemplate(dataSource); &#125; public int[][] batchUpdate(final Collection&lt;Actor&gt; actors) &#123; int[][] updateCounts = jdbcTemplate.batchUpdate( "update t_actor set first_name = ?, last_name = ? where id = ?", actors, 100, new ParameterizedPreparedStatementSetter&lt;Actor&gt;() &#123; public void setValues(PreparedStatement ps, Actor argument) throws SQLException &#123; ps.setString(1, argument.getFirstName()); ps.setString(2, argument.getLastName()); ps.setLong(3, argument.getId().longValue()); &#125; &#125;); return updateCounts; &#125; // ... additional methods&#125; 此调用的批处理更新方法返回一个 int 二维数组，第一维数组的长度表示执行的批处理数，第二维数组的长度表示该批处理中的更新数。每个批次中的更新数量应该为所有批次提供的批量大小，但最后一个批次可能会减少，具体取决于提供的更新对象总数。每个更新语句的更新计数由 JDBC 驱动程序报告，如果计数不可用，则 JDBC 驱动程序返回 -2。 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十二）—— 事务管理之不同方式的使用]]></title>
      <url>%2F2016%2F11%2F23%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B9%8B%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[编程式的事务管理Spring 提供了两个模板类 TransactionTemplate 和 PlatformTransactionManager 来支持编程式事务管理，与其他的持久化模板一样，都是线程安全的。一般使用前者，后者类似与 JTA UserTransaction API。 使用 TransactionTemplate编写一个 TransactionCallback 实现类（通常为匿名内部类），该实现包含需要在事务上下文中执行的代码。然后，将自定义 TransactionCallback 的实例传递给 TransactionTemplate 的 execute() 方法。1234567891011121314151617181920public class SimpleService implements Service &#123; // single TransactionTemplate shared amongst all methods in this instance private final TransactionTemplate transactionTemplate; // use constructor-injection to supply the PlatformTransactionManager public SimpleService(PlatformTransactionManager transactionManager) &#123; Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null."); this.transactionTemplate = new TransactionTemplate(transactionManager); &#125; public Object someServiceMethod() &#123; return transactionTemplate.execute(new TransactionCallback() &#123; // the code in this method executes in a transactional context public Object doInTransaction(TransactionStatus status) &#123; updateOperation1(); return resultOfUpdateOperation2(); &#125; &#125;); &#125;&#125; 如果执行事务回调的时候没有返回值，则使用 TransactionCallbackWithoutResult 代替 TransactionCallback，且可以调用 TransactionStatus 对象的 setRollbackOnly() 方法回滚事务：12345678910transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; protected void doInTransactionWithoutResult(TransactionStatus status) &#123; try &#123; updateOperation1(); updateOperation2(); &#125; catch (SomeBusinessExeption ex) &#123; status.setRollbackOnly(); &#125; &#125;&#125;); TransactionTemplate 的事务设置可以通过编程方式或配置文件指定，如传播方式，隔离级别，超时等，TransactionTemplate 实例默认情况下具有默认事务设置。 编程方式： 1234567891011public class SimpleService implements Service &#123; private final TransactionTemplate transactionTemplate; public SimpleService(PlatformTransactionManager transactionManager) &#123; Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null."); this.transactionTemplate = new TransactionTemplate(transactionManager); // the transaction settings can be set here explicitly if so desired this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED); this.transactionTemplate.setTimeout(30); // 30 seconds // and so forth... &#125;&#125; 配置文件方式： 12345&lt;bean id="sharedTransactionTemplate" class="org.springframework.transaction.support.TransactionTemplate"&gt; &lt;property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/&gt; &lt;property name="timeout" value="30"/&gt;&lt;/bean&gt;" 使用 PlatformTransactionManager使用 PlatformTransactionManager 直接管理事务，使用 TransactionDefinition 和 TransactionStatus 对象启动，回滚和提交事务。1234567891011121314DefaultTransactionDefinition def = new DefaultTransactionDefinition();// explicitly setting the transaction name is something that can only be done programmaticallydef.setName("SomeTxName");def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);TransactionStatus status = txManager.getTransaction(def);try &#123; // execute your business logic here&#125;catch (MyException ex) &#123; txManager.rollback(status); throw ex;&#125;txManager.commit(status); 使用 XML 配置声明式事务管理使用声明式事务管理的方式，对代码的侵入性最小，可以让事务管理代码完全从业务代码中移除，非常符合非侵入式轻量级容器的概念。Spring 的声明式事务管理是通过 Spring AOP 实现的，通过事务的声明性信息，Spring 负责将事务管理增强逻辑动态织入到业务方法相应的连接中。这些逻辑包括获取线程绑定资源、开始事务、提交/回滚事务、进行异常转换和处理等工作。Spring 提供了和 EJB CMT 相似的声明式事务管理，这不但体现在两者的最终执行效果上，还体现在两个声明事务的语法上，即便如此，两者仍存在明显的不同： 比较项 EJB CMT Spring 是否绑定 JTA 绑定在 JTA 上，即便是单数据源，所以 EJB 不能脱离容器运行 可以在任何环境下使用，包括直接在 Spring 中声明的数据源或应用服务器 JNDI 中的 JTA 数据源 持久化技术支持 采用非开发放的 EJB 自制持久化技术 通过少量配置即可和 JDBC、JDO、Hibernate 等持久化技术一起工作 目标类要求 必须是实现特定接口的特殊类 可以是任何 POJO，不过在内部必须使用资源获取工具类操作数据连接或会话，如果 DAO 使用模板类进行构建，这种要求将自动得到满足 回滚规则 没有 提供声明式的回滚规则 开放性控制 使用 EJB CMT，除了使用 setRollbackOnly()，没有办法影响容器的事务管理 Spring 允许用户通过 AOP 定制事务行为。如：用户可以在事务回滚中插入定制的行为，也可以增加任意的增强，就和任何 AOP 的增强一样 分布式事务 支持分布式事务，一般应用并不需要使用这样的功能 Spring 不直接支持高端应用服务器所提供的跨越远程调用的事务上下文传播。此时可以通过 Spring 的 Java EE 服务集成来提供。此外，如果在 Spring 中集成 JOTM 后，Spring 也可以提供 JTA 事务的功能 示例FooService 是业务层的接口(需要实施事务增强的服务接口)，通过 Spring 的声明事务可以让这个接口的方法拥有是适合的事务功能。12345678// 需要实施事务增强的服务接口package x.y.service;public interface FooService &#123; Foo getFoo(String fooName); Foo getFoo(String fooName, String barName); void insertFoo(Foo foo); void updateFoo(Foo foo);&#125; 1234567891011121314151617181920// 上述接口实现package x.y.service;public class DefaultFooService implements FooService &#123; public Foo getFoo(String fooName) &#123; throw new UnsupportedOperationException(); &#125; public Foo getFoo(String fooName, String barName) &#123; throw new UnsupportedOperationException(); &#125; public void insertFoo(Foo foo) &#123; throw new UnsupportedOperationException(); &#125; public void updateFoo(Foo foo) &#123; throw new UnsupportedOperationException(); &#125;&#125; 假设 FooService 接口的前两个方法 getFoo(String) 和 getFoo(String，String) 必须在具有只读语义的事务上下文中执行，而其他方法 insertFoo(Foo) 和 updateFoo(Foo) 必须在具有读写语义的事务上下文中执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 文件'context.xml' --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置事务用的 Service 对象 --&gt; &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt; &lt;!-- 事务增强 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;!-- 事务属性定义 --&gt; &lt;tx:attributes&gt; &lt;!-- 所有以'get'开头的方法都是只读的 --&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;!-- other methods use the default transaction settings (see below) --&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 使用强大的切点表达式语言定义目标方法 --&gt; &lt;aop:config&gt; &lt;!-- 通过 aop 定义事务增强切面 --&gt; &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt; &lt;!-- 引用事务增强 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt; &lt;/aop:config&gt; &lt;!-- don't forget the DataSource --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt; &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt; &lt;property name="username" value="scott"/&gt; &lt;property name="password" value="tiger"/&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt; 根据上述配置，我们需要一个 Service 对象，fooService bean，事务。要应用的事务语义封装在 定义中，&lt;tx:advice /&gt; 中表示所有以’get’开头的方法都是只读的，所有其他方法都将使用默认事务语义。&lt;tx:advice /&gt; 标签的 transaction-manager 属性为事务管理器 PlatformTransactionManager bean 的名称（在本例中为 txManager bean），如果事务管理器命名为 transactionManager，则可以不指定 transaction-manager 属性。&lt;aop:config /&gt; 确保 由 txAdvice bean 定义的事务增强 能在程序中的适当位置执行。首先定义一个切点，该切点匹配 FooService 接口（fooServiceOperation）中定义的所有方法。然后使用 advisor 将切点与 txAdvice 关联，在执行 fooServiceOperation 时，将运行由 txAdvice 定义的增强。上述配置将用于围绕从 fooService bean 定义创建的对象创建事务代理。使用事务增强配置代理，以便在代理上调用适当的方法时，根据与该方法关联的事务配置，将事务启动，挂起，标记为只读。1234567public final class Boot &#123; public static void main(final String[] args) throws Exception &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class); FooService fooService = (FooService) ctx.getBean("fooService"); fooService.insertFoo (new Foo()); &#125;&#125; 回滚 XML 配置声明式事务在 Spring 框架中，事务回滚的推荐方法为：从当前在事务上下文中执行的代码中抛出异常。Spring 框架的事务基础结构代码将捕获任何未处理的异常，并确定是否将事务标记为回滚。在其默认配置中，Spring框架的事务基础结构代码只在发生 RuntimeException 和 unchecked 异常的情况下标记用于回滚的事务（即当抛出的异常是 RuntimeException 的实例或子类时）；从事务方法抛出的 checked 异常不会导致在默认配置中回滚。我们可以自己配置通过哪些异常类型标记事务以进行回滚（包括检查异常），以下为 XML 配置的代码：123456&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 也可以指定不进行事务回滚的异常，这样当应用程序抛出该异常时，不进行事务回滚：123456&lt;tx:advice id="txAdvice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/&gt; &lt;tx:method name="*"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 如下 XML 配置表示除了 InstrumentNotFoundException 之外，其余的异常都进行回滚：12345&lt;tx:advice id="txAdvice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; tx:advice 标签的属性事务的设置可以使用 &lt;tx:advice/&gt; 标签指定，其默认的 &lt;tx:advice/&gt; 设置为： 传播行为：REQUIRED； 隔离级别：DEFAULT； 读写事务属性：读/写事务； 超时时间：默认为基础事务系统的默认超时，如果不支持超时，则为无； 回滚设置：任意 RuntimeException 会触发回滚，而 checked Exception 不会。 &lt;tx:method/&gt; 的设置： 属性 是否必须 默认值 描述 name 是 与事务关联的方法名，可使用通配符* 如 get、handle等 propagation 否 REQUIRED 事务传播行为，可选值：REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED isolation 否 DEFAULT 事务隔离级别，可选值：DEFAULT、READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ、SERIALIZABLE timeout 否 -1 事务超时的时间（以秒为单位），如果设置为 -1，事务超时的时间由底层的事务系统决定 read-only 否 false 事务是否只读 rollback-for 否 所有 RuntimeException 触发事务回滚的 Exception，用异常名称的片断进行匹配，可以设置多个，以逗号分开 no-rollback-for 否 所有 checked Exception 不触发事务回滚的 Exception，用异常名称的片断进行匹配，可以设置多个，以逗号分开 使用注解配置声明式事务管理除了基于 XML 的事务配置之外，Spring 还提供了基于注解的事务配置，即通过 @Transactional 对需要事务增强的 Bean 接口、实现类或方法进行标注，在容器中配置基于注解的事务增强驱动，即可启动基于注解的声明式事务。 使用 @Transactional 注解使用 @Transactional 注解的将要实现事务增强的实现类：12345678// the service class that we want to make transactional@Transactionalpublic class DefaultFooService implements FooService &#123; Foo getFoo(String fooName); Foo getFoo(String fooName, String barName); void insertFoo(Foo foo); void updateFoo(Foo foo);&#125; 当上述的 POJO 在 Spring IOC 容器中定义为 Bean 时，可以通过仅添加一行 XML 配置来为 Bean 实例实现事务增强：123456789101112131415161718192021222324252627&lt;!-- from the file 'context.xml' --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 由于该 Bean 实现类标注了 @Transactional，所以将会被 tx:annotation-driven 标签的注解驱动自动织入事务 --&gt; &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt; &lt;!-- 对标注 @Transactional 注解的 Bean 进行加工处理，以织入事务管理切面 --&gt; &lt;tx:annotation-driven transaction-manager="txManager"/&gt; &lt;!-- a PlatformTransactionManager is still required --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- (this dependency is defined somewhere else) --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- other &lt;bean/&gt; definitions here --&gt;&lt;/beans&gt; 默认情况下，&lt;tx:annotation-driven&gt; 会自动使用名称为 transactionManager 的事务管理器，所以如果事务管理器的 id 为 transactionManager 时，可以简化为 &lt;tx:annotation-driven/&gt;。&lt;tx:annotation-driven/&gt; 有四个属性： transaction-manager：其 Annotation 属性为 TransactionManagementConfigurer，默认值为 transactionManager。 mode：其 Annotation 属性为 mode，默认值为 proxy，默认模式 proxy 使用 Spring 的 AOP 框架处理要被代理的带注释的 bean。替代模式 aspectj 改为用 Spring 的 AspectJ 事务切面编织受影响的类，修改目标类字节码以用于任意方法的调用。AspectJ 编织需要在类路径中使用 spring-aspects.jar 以及启用加载时编织（或编译时编织）。 proxy-target-class：其 Annotation 属性为 proxyTargetClass，默认值为 false。如果为 true，Spring 将通过子类来代理业务类；为 false，则使用基于接口的代理，需要在类路径中添加 CGLib.jar 类库。 order：其 Annotation 属性为 order，其默认值为 Ordered.LOWEST_PRECEDENCE。如果业务类除事务切面外，还需要织入其他的切面，通过该属性可以控制事务切面在目标连接点的织入顺序。 @Transactional 的属性@Transactional 的默认属性： 传播行为：PROPAGATION_REQUIRED； 隔离级别：ISOLATION_DEFAULT； 读写事务属性：读/写事务； 超时时间：默认为基础事务系统的默认超时，如果不支持超时，则为无； 回滚设置：任意 RuntimeException 会触发回滚，而 checked Exception 不会。 @Transactional 属性说明： value：String 类型，指定要使用的事务管理器的可选限定符。 propagation：事务传播行为，通过枚举类（org.springframework.transaction.annotation.Propagation）提供合法值；如：@Transactional(propagation=Propagation.REQUIRES_NEW)。 isolation：事务隔离级别，通过枚举类（org.springframework.transaction.annotation.Isolation）提供合法值；如：@Transactional(isolation=Isolation.READ_COMMITTED)。 readOnly：事务读写性，boolean 型；如：@Transactional(readOnly=true)。 timeout：超时时间，int 型，以秒为单位；如：@Transactional(timeout=0)。 rollbackFor：一组异常类，遇到时进行回滚，类型为 Class&lt;? extends Throwable&gt;[]，默认为{}；如：@Transactional(rollbackFor={SQLException.class})，多个异常之间可用逗号分隔。 rollbackForClassName：一组异常类，遇到时进行回滚，类型为 String[]，默认为{}；如：@Transactional(rollbackForClassName={“Exception”})。 noRollbackFor：一组异常类，遇到时不回滚，类型为 Class&lt;? extends Throwable&gt;[]，默认为{}。 noRollbackForClassName：一组异常类，遇到时不回滚，类型为 String[]，默认为{}。 @Transactional 使用不同的事务管理器大多数情况下，一个应用仅需一个事务管理器，如果希望在不同的地方使用不同的事务管理器，可如下实现：123456789public class TransactionalService &#123; // 使用名为 order 的事务管理器 @Transactional("order") public void setSomething(String name) &#123; ... &#125; // 使用名为 account 的事务管理器 @Transactional("account") public void doSomething() &#123; ... &#125;&#125; order 和 account 事务管理器在 XML 中的定义：12345678910&lt;tx:annotation-driven/&gt; &lt;bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; ... &lt;qualifier value="order"/&gt;&lt;!-- 为事务管理器标识一个名字 --&gt; &lt;/bean&gt; &lt;bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; ... &lt;qualifier value="account"/&gt; &lt;/bean&gt; 在一两处使用带标识的 @Transactional 也许挺合适，但是如果到处都使用，则显得繁琐。可以自定义一个绑定到特定事务管理器的注解，然后直接使用这个自定义的注解进行标识：1234567891011@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Transactional("order")public @interface OrderTx &#123;&#125;@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Transactional("account")public @interface AccountTx &#123;&#125; 按相似的方法，还可以定义一个绑定到 order 事务管理器的 @OrderTx，完成定义后，就可以用以下方式对原来的代码进行调整了。12345678public class TransactionalService &#123; @OrderTx public void setSomething(String name) &#123; ... &#125; @AccountTx public void doSomething() &#123; ... &#125; &#125;&#125; 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十一）—— 事务管理之 ThreaLocal]]></title>
      <url>%2F2016%2F11%2F22%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B9%8B%20ThreaLocal%2F</url>
      <content type="text"><![CDATA[按照传统的经验，如果某个对象是非线程安全的，在多线程环境下，对对象的访问必须采用 synchronized 进行线程同步，但线程同步机制会降低并发性，影响系统性能。ThreaLocal 可以改变这种方式。 认识 JDK 1.2 版本开始提供 java.lang.ThreaLocal，ThreaLocal 为解决多线程程序的并发问题提供了新的思路。ThreaLocal 是线程的一个本地化对象，当工作于多线程中的对象使用 ThreadLocal 维护变量时，它会为每个使用该变量的线程分配一个独立的变量副本。所有每个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本；从线程的角度看，这个变量就像是线程的本地变量。 接口方法ThreadLocal 支持泛型，且有四个简单的接口： void set(T value)：设置当前线程的线程局部变量的值。 public T get()：该方法返回当前线程所对应的线程局部变量。 public void remove()：将当前线程局部变量的值删除，目的是为了减少内存的占用（JDK 5.0 新增）。当线程结束后，对应该线程的局部变量将会自动被垃圾回收，所以显示调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 protected T initialValue()：返回该线程局部变量的初始值，该方法是一个 protected 方法，为了让子类覆盖而设计。 ThreadLocal 的实现思路：在 ThreadLocal 内部有一个 Map，用于存储每一个线程的变量副本，Map 中的元素的 key 为线程对象，value 为对应线程的变量副本。 实例12345678910111213141516171819202122232425262728293031323334353637public class SequenceNumber &#123; private static class TestClient extends Thread &#123; private SequenceNumber sn; public TestClient(SequenceNumber sn) &#123; this.sn = sn; &#125; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println("Thread[" + Thread.currentThread().getName() + "] sn[" + sn.getNextNum() + "]") &#125; &#125; &#125; private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() &#123; public Integer initialValue() &#123; return 0; &#125; &#125;; public int getNextNum() &#123; seqNum.set(seqNum.get() + 1); return seqNum.get(); &#125; public static void main(String[] args) &#123; SequenceNumber sn = new SequenceNumber(); TestClient t1 = new TestClient(sn); TestClient t2 = new TestClient(sn); TestClient t3 = new TestClient(sn); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果：123456789Thread[Thread-2] sn[1]Thread[Thread-0] sn[1]Thread[Thread-1] sn[1]Thread[Thread-2] sn[2]Thread[Thread-0] sn[2]Thread[Thread-1] sn[2]Thread[Thread-2] sn[3]Thread[Thread-0] sn[3]Thread[Thread-1] sn[3] 从输出结果上看，由于 ThreadLocal 为每一个线程提供了单独的副本，所以每个线程所产生的序号虽然都共享同一个 SequenceNumber 实例，但它们没有发生相互干扰的情况，而是各自产生独立的序列号。 与线程同步机制的比较在线程同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序解决什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等复杂的问题。ThreadLocal 从另一个角度解决多线程的并发访问，为每个线程提供独立的变量副本，从而隔离了多个线程对访问数据的冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对变量进行同步。ThreadLocal 提供了线程安全的对象封装，在编写多线程代码时，可以把部安全的变量封装进 ThreadLocal。总的来说，同步机制采用“以时间换空间”的方式：访问串行化，对象共享化；而 ThreadLocal 采用“以空间换时间”的方式：访问并行化，对象独享化。 参考资料：Spring 3.x 企业应用开发实战]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十）—— 事务管理之数据库事务基础知识]]></title>
      <url>%2F2016%2F11%2F22%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[概念数据库事务(Database Transaction)，是指作为单个逻辑工作单元执行的一系列操作（可理解为对数据库的简单操作，如：增删查改），要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作（将一组相关操作组合为一个单元）都成功完成，否则不会将数据库操作真正地写入数据库，如此简化错误恢复的实现，并使应用程序更加可靠。数据库事务必须满足 4 大特性（简称 ACID）： 原子性（Atomic）：表示包含多个数据库操作的事务只有所有操作都成功，整个事务才提交；若其中一个操作失败，则撤销所有操作，让数据库返回初始状态。 一致性（Consistency）：事务操作成功后，数据库整体状态与业务规则一致。如 A 转账 100 给 B，不论操作是否成功，A 和 B 的存款总额不变。 隔离性（Isolation）：并发操作中，不同事务拥有各自的数据空间，且彼此的操作不会相互干扰。 持久性（Durability）：一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证能够通过某种机制恢复数据。 数据并发多个客户端连接同一个数据库进行并发访问时，数据库中的同一个数据可能会被多个事务访问，这时需要采用适当的隔离措施，保护数据的完整性。 脏读A 事务读取 B 事务尚未提交的更改数据，并在此基础上进行操作。当 B 进行事务回滚时，则 A 事务读取的数据不会被承认。下图中黑点代表开始事务，白点表示提交事务。 不可重复读不可重复读指 A 事务读取数据后，B 事务执行更新操作，使 A 事务无法再现前一次读取结果。 幻读A 事务读取 B 事务提交的新增数据。幻读和不可重复读不一样，前者是指读到了其他已经提交事务的新增数据，后者指读到了已经提交事务的更改数据；防止读取到更改数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生变化，而防止读取到新增数据，往往需要添加表级锁（将整个表锁定，防止新增数据）。 第一类丢失修改A 事务撤销时，把已经提交的 B 事务的更新数据覆盖了。 第二类丢失修改A 事务覆盖 B 事务已经提交的数据，造成 B 事务所做操作丢失。 数据库锁机制按锁定的对象的不同，一般可以分为表锁定和行锁定，前者对整个表进行锁定，而后者对表中特定行进行锁定。从并发事务锁定的关系上看，可以分为共享锁定和独占锁定。共享锁定会防止独占锁定，但允许其他的共享锁定；而独占锁定既防止其他的独占锁定，也防止其他的共享锁定。 事务隔离数据库为用户提供了锁的 DML 操作方式，但直接使用锁管理比较麻烦，因此数据库为用户提供可自动锁机制。只要用户指定回话的事务隔离级别，数据库就会分析事务中的 SQL 语句，然后自动为事务操作的数据资源添加适当的锁。ANISI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，在相同的数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。 隔离级别 脏读 不可重复读 幻读 第一类丢失修改 第二类丢失修改 READ UNCOMMITTED 允许 允许 允许 不允许 允许 READ COMMITTED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（九）—— AOP 之资源访问接口 Resource]]></title>
      <url>%2F2016%2F11%2F21%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%20AOP%20%E4%B9%8B%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%20Resource%2F</url>
      <content type="text"><![CDATA[JDK 提供的访问资源的类（java.net.URL 和 File）不能满足各种底层资源的访问需求，比如缺少从类路径或 Web 容器的上下文中获取资源的操作类。因此，Spring 设计了一个 Resource 接口，为应用提供了更强的访问底层资源的能力。 资源接口 Resource123456789public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isOpen(); URL getURL() throws IOException; File getFile() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; 123public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125; Resource 接口的主要方法： getInputStream()：返回资源对应的输入流。 exists()：资源是否存在。 isOpen()：资源是否打开。 getDescription()：返回对资源的描述。 getURL()：如果底层资源可以表示成URL，则返回对应的 URL 对象。 getFile()：如果底层资源对应一个文件，则返回对应的 File 对象。 Resource 的具体实现类 UrlResource：Url 封装了 java.net.URL，它使用户能够访问任何可以通过 URL 表示的资源，如文件系统的资源、HTTP 资源、FTP 资源等。 ClassPathResource：类路径下的资源，资源以相对于类路径的方式表示。 FileSystemResource：文件系统资源，资源以文件系统路径的方式表示。 ServletContextResource：为访问 Web 容器上下文中的资源而设计的类，负责以相对于 Web 应用根目录的路径加载资源，它支持以流和 URL 的方式访问，在 WAR 解包的情况下，也可以通过 File 的方式访问，该类还可以直接从 JAR 包中访问资源。 InputStreamResource：以输入流返回表示的资源。 ByteArrayResource：二进制数组表示的资源，二进制数组资源可以在内存中通过程序构造。 示例：1234567891011121314151617181920import java.io.IOException;import java.io.InputStream;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.FileSystemResource;import org.springframework.core.io.Resource;public class ResourceTest &#123; public static void main(String[] args) &#123; try &#123; String filePath = "D:/config/file.txt"; // 使用系统文件路径方式加载文件 Resource res1 = new FileSystemResource(filePath); // 使用类路径方式加载文件 Resource res1 = new ClassPathResource("conf/file.txt"); InputStream ins1 = res1.getInputStream(); InputStream ins2 = res2.getInputStream(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 资源地址表达式Spring 提供了强大的加载资源的机制，不但能够通过 classpath:、file: 等资源地址前缀识别不同的资源类型，还支持 Ant 风格带通配符的资源地址。 地址前缀 示例 对应资源类型 classpath: classpath:com/myapp/config.xml 从类路径中加载资源，资源文件可以在标准的文件系统中，也可以在 jar 或 zip 的类包中 file: file://data/config.xml 使用 UrlResource 从文件系统目录中装载资源，可采用绝对或相对路径 http:// http://myserver/logo.png 使用 UrlResource 从 Web 服务器中装载资源 ftp:// ftp://myserver/my.txt 使用 UrlResource 从 FTP 服务器中装载资源 没有前缀 /data/config.xml 根据 ApplicationContext 具体实现类采用对应的类型的 Resource Ant 风格资源地址支持 3 种匹配符： ?：匹配文件名中的一个字符 *：匹配文件名中任意个字符 **：匹配多层路径 示例： classpath:com/t?st.xml：匹配 com 类路径下 com/test.xml，com/tast.xml 或者 com/tdst.xml file:D:/conf/*.xml：匹配文件系统 D:/conf 目录下所有以 xml 为后缀的文件 classpath:com/**/test.xml：匹配 com 类路径下（当前目录及其子孙目录）的 test.xml 文件 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（八）—— AOP 之基于 Schema 配置]]></title>
      <url>%2F2016%2F11%2F20%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%20AOP%20%E4%B9%8B%E5%9F%BA%E4%BA%8E%20Schema%20%E7%9A%84%20AOP%20%E6%94%AF%E6%8C%81%2F</url>
      <content type="text"><![CDATA[Spring 提供了使用新的 aop 命名标签定义切面的支持，使得我们可以使用 Schema 配置切面。基于 @AspectJ 注解的切面，本质上是将切点、增强类型的信息使用注解进行描述；而在基于 Schema 的实现方式中，把这两个信息移到 Schema 的 XML 配置文件中。虽然配置方式不同，但两者表达的信息完全相同。使用基于 Schema 的切面定义后，切点、增强类型的注解信息从切面类中剥离出来，原本的切面类变成了真正意义上的 POJO。在 Spring 配置中，所有的 aspect、pointcut 和 advisor 元素都需要放置在 &lt;aop:config&gt; 元素之下。 声明切面（aspect）使用 Schema 支持时，一个切面只是一个 POJO 类，它在 Spring 应用程序上下文中定义为一个 Bean。状态和行为由对象的字段和方法提供，切点和增强由 XML 配置文件提供。切面的声明使用 &lt;aop:aspect&gt; 元素，而 bean 使用 ref 属性注入。12345678&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aBean" class="..."&gt; ...&lt;/bean&gt; 声明切点（pointcut）使用切点表达式的方式：1234&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;&lt;/aop:config&gt; 直接声明切点的方式：1234&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;&lt;/aop:config&gt; 声明增强（advice）和 @AspecJ 所支持的类型一致，sechema 也支持 5 种增强方式，且在使用方法上也大致相同。参考 Spring笔记（七）—— AOP 之 @AspectJ 支持 Before advice在 &lt;aop:aspect&gt; 元素下使用 &lt;aop:before&gt; 子元素声明。12345&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; 上面的 dataAccessOperation 是切点的 id，要直接定义切点，需要使用 pointcut 属性代替 pointcut-ref：12345&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut="execution(* com.xyz.myapp.dao.*.*(..))" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; After returning advice使用 returning 属性指定传递返回值的参数名：1234567&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" returning="retVal" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; doAccessCheck 方法必须声明一个名为 retVal 的参数，此参数的类型以与 @AfterReturning 中所述相同的方式约束匹配。1public void doAccessCheck(Object retVal) &#123;...&#125; After throwing advice使用 throwing 属性指定应传递异常的参数的名称：1234567&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" throwing="dataAccessEx" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt; doRecoveryActions 方法必须声明一个名为 dataAccessEx 的参数：1public void doRecoveryActions(DataAccessException dataAccessEx) &#123;...&#125; After (finally) advice123456&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt; &lt;aop:after pointcut-ref="dataAccessOperation" method="doReleaseLock"/&gt; ...&lt;/aop:aspect&gt; Around adviceAround advice 通常于线程安全的方式下，在要执行的方法前后分享状态时使用。123456&lt;aop:aspect id="aroundExample" ref="aBean"&gt; &lt;aop:around pointcut-ref="businessService" method="doBasicProfiling"/&gt; ...&lt;/aop:aspect&gt; 123456public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal;&#125; Introductions通过 &lt;aop:declare-parents&gt; 配置引介增强，引介增强和其它类型的增强不同，它没有 method、pointcut 和 pointcut-ref 属性：123456789&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt; &lt;aop:declare-parents types-matching="com.xzy.myapp.service.*+" implement-interface="com.xyz.myapp.service.tracking.UsageTracked" default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt; &lt;aop:before pointcut="com.xyz.myapp.SystemArchitecture.businessService() and this(usageTracked)" method="recordUsage"/&gt;&lt;/aop:aspect&gt; &lt;aop:declare-parents&gt; 通过 implement-interface 属性声明要实现的接口，通过 default-impl 属性指定默认的接口实现类，通过 types-matching 属性以 AspectJ 切点表达式语法指定哪些 Bean 需要引介 UsageTracked 接口的实现。注意：虽然 &lt;aop:declare-parents&gt; 没有 method 属性指定增强方法所在的 Bean，但 &lt;aop:aspect id=&quot;usageTrackerAspect&quot; ref=&quot;usageTracking&quot;&gt; 的 ref 属性依然要指定一个增强 Bean。 AdvisorsAdvisors 是 Spring 中切面概念的对应物，是切点和增强的复合体，不过仅包含一个切点和一个增强。在 AspectJ 中没有对应的等价物，在 aop Schema 配置样式中，可以通过 &lt;aop:advisor&gt; 配置一个 Advisor。通过 advice-ref 属性引用基于接口定义的增强，通过 pointcut 定义切点表达式，或通过 pointcut-ref 引用一个命名的切点。123456789101112&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; &lt;aop:advisor pointcut-ref="businessService" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（七）—— AOP 之 @AspectJ 支持]]></title>
      <url>%2F2016%2F11%2F19%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%20AOP%20%E4%B9%8B%20%40AspectJ%20%E6%94%AF%E6%8C%81%2F</url>
      <content type="text"><![CDATA[开启 @AspectJ 支持@AspectJ 指的是使用注解标注的常规 Java 类的样式声明切面，@AspectJ 样式是 AspectJ 项目引入的，作为 AspectJ 5 版本的一部分。Spring 使用由 AspectJ 提供的库 aspectjweaver.jar（要求版本至少为 1.6.8），就能像 AspectJ 5 那样解析注解。 Java 配置方式1234@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125; XML 配置方式1&lt;aop:aspectj-autoproxy/&gt; 声明切面（aspect）当开启 @AspectJ 支持时，任何在应用程序上下文中使用类（包含 @AspectJ 注解）定义的 bean 都会被 Spring 侦测到，并用于配置 Spring AOP。如下为应用程序上下文中的常规 bean 定义，指向具有 @AspectJ 注解的 bean 类：123&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt; &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt; 还有具有 @AspectJ 注解的 NotVeryUsefulAspect 类：12345package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125; 声明切点（pointcut）切点能够定位特定的连接点，从而使我们能够控制何时执行增强操作。切点声明有两部分：一个包含方法名和任意参数的签名，以及一个切入点表达式（它标明要执行的方法的位置）。在 AOP 的 @AspectJ 注解风格中，切点签名由一个常规方法定义，切点表达式使用 @Pointcut 注解表示（用作切点签名的方法必须具有 void 返回类型）。12@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature 切点表达式函数Aspectj5 的切点表达式由关键字和操作参数组成，如 execution(* transfer(..))，execution 为关键字，* transfer(..) 为操作参数。在上面的例子中，execution 代表目标类执行某一方法，* transfer(..) 描述目标方法的匹配模式串，两个联合起来表示目标类 transfer() 方法的连接点。 Spring 支持 9 个 @AspectJ 切点表达式函数，它们用不同的方式描述目标类的连接点，根据描述对象的不同，大致分为 4 个类型： 方法切点函数：通过描述目标类方法信息定义连接点。 execution(方法匹配模式串)：表示满足某一匹配模式的所有目标方法连接点。如 execution(* transfer(..)) 表示所有目标类中的 transfer() 方法；execution(public * *(..)) 表示所有目标类中的 public 方法。 @annotation(方法注解类名)：表示标注了特定注解的目标方法连接点。如 @annotation(com.lake.NeedTest) 表示任何标注了 @NeedTest 注解的目标类方法。 方法入参切点函数：通过描述目标类方法入参的信息定义连接点。 args(类名)：通过判别目标类方法运行时入参对象的类型定义指定连接点。如 args(com.lake.Waiter) 表示所有有且仅有一个按类型匹配于 Waiter 入参的方法。 @args(类型注解类名)：通过判别目标方法运行时入参对象的类是否标注特定注解来指定连接点。如 @args(com.lake.Monitorable) 表示任何这样的一个目标方法：它有一个入参且入参对象的类标注 @Monitorable 注解。 目标类切点函数：通过描述目标类类型信息定义连接点。 within(类名匹配串)：表示特定域下的所有连接点。如 within(com.lake.service.*) 表示 com.lake.service 包中的所有连接点，即包中所有类的所有方法，而 within(com.lake.service.*Service) 表示在 com.lake.service 包中所有以 Service 结尾的类的所有连接点。 target(类名)：假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过 target(com.lake.Waiter) 定义的切点、Waiter 以及 Waiter 实现类 NativeWaiter 中所有连接点都匹配该切点。 @within(类型注解类名)：假如目标类按类型匹配于某个类 A，且类 A 标注了特定注解，则目标类的所有连接点匹配这个切点。如 @within(com.lake.Monitorable) 定义的切点，假如 Waiter 类标注了 @Monitorable 注解，则 Waiter 以及Waiter 实现类 NativeWaiter 中所有连接点都匹配。 @target(类型注解类名)：目标类标注了特定注解，则目标类所有连接点匹配这个切点。如 @target(com.lake.Monitorable) 定义的切点，假如 NativeWaiter 类标注了 @Monitorable 注解，则 NativeWaiter 所有连接点都匹配切点。 代理类切点函数：通过描述目标类的代理类的信息定义连接点。 this(类名)：代理类按类型匹配于指定类，则被代理的目标类所有连接点匹配切点。 函数入参通配符@AspectJ 支持 3 种通配符： * ：匹配任意字符，但它只能匹配上下文中的一个元素 .. ：匹配任意字符，可以匹配上下文中的多个元素，但在表示类时，必须和 * 联合使用，而在表示入参时则单独使用 + ：表示按类型匹配指定类的所有类，必须跟在类名后面，如 com.lake.Car+。继承或扩展指定类的所有类，同时还包括指定类本身 @AspectJ 函数按其是否支持通配符及支持的程度，分为 3 类： 支持所有通配符：execution(), within() 仅支持 + 通配符：args(), this(), target() 不支持通配符：@args(), @within(), @target(), @annotation() 逻辑运算符切点表达式由切点函数组成，切点函数之间还可以进行逻辑运算，组成复合切点，Spring 支持以下切点运算符： &amp;&amp; ：与操作符，等效符号 and。如 within(com.lake.*) and args(String) 表示在 com.lake 包下所有类拥有一个 String 入参的方法 || ：或操作符，等效符号 or。如 within(com.lake..*) and args(String) 表示在 com.lake 包下所有类（当前包以及子孙包）的方法，或所有拥有一个 String 入参的方法 ! ：非操作符，等效符号 not。如 !within(com.lake.*) 表示所有不在 com.lake 包下的方法 声明增强（advice）Spring 使用增强定义横切逻辑，同时由于 Spring 只支持方法连接点，增强还包括了在方法的哪一点加入横切代码的方位信息，所以增强既包括横切逻辑，还包括部分连接点。增强与切点表达式相关联，并在切点匹配的方法执行之前，之后或周围运行。切点表达式可以是对指定切点的简单引用，也可以是在适当位置声明的切入点表达式。所有增强类型除了引介增强，其余都属于方法级别的。 @Before前置增强表示在目标方法执行前实施增强（即先执行增强方法中的代码）。使用 @Before 声明前置增强，其拥有两个属性： vlaue：该成员用于定义切点。 argNames：由于无法通过 Java 反射机制获取方法入参名，所有如果在 Java 编译时未启动调试信息或者需要在运行期解析切点，就必须通过这个成员指定注解多标注增强方法的参数名（注意两者名字必须完全相同），多个参数名用逗号分隔。 12345678910111213import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class BeforeExample &#123; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @Before("execution(* com.xyz.myapp.dao.*.*(..))") public void doAccessCheck2() &#123; // ... &#125;&#125; 如上所示，doAccessCheck() 方法会在 SystemArchitecture 类的 dataAccessOperation() 方法执行之前先执行；doAccessCheck2() 会在表达式所匹配的方法执行之前执行。 @AfterReturning后置增强表示在目标方法执行后实施增强（即后执行增强方法中的代码）。使用 @AfterReturning 声明后置增强，其拥有四个属性： vlaue：该成员用于定义切点。 pointcut：表示切点的信息，如果显示指定 pointcut 值，它将覆盖 value 的设置值，可以将 pointcut 属性看成 value。 returning：将目标对象方法的返回值绑定给增强的方法。 argNames：如上所述 123456789101112131415import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample &#123; @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @AfterReturning( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal") public void doAccessCheck2(Object retVal) &#123; // ... &#125;&#125; @Around环绕增强表示在目标方法执行前后实施增强（即前后都执行增强方法中的代码）。使用 @Around 声明环绕增强，其拥有两个属性： vlaue：该成员用于定义切点。 argNames：如上所述 12345678910111213import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.ProceedingJoinPoint;@Aspectpublic class AroundExample &#123; @Around("com.xyz.myapp.SystemArchitecture.businessService()") public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; &#125;&#125; @AfterThrowing异常抛出增强表示在目标方法抛出异常后实施增强。使用 @AfterThrowing 声明抛出增强，其拥有四个属性： vlaue：该成员用于定义切点。 pointcut：表示切点的信息，如果显示指定 pointcut 值，它将覆盖 value 的设置值，可以将 pointcut 属性看成 value。 returning：将抛出的异常绑定给增强的方法。 argNames：如上所述 123456789101112131415import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class AfterThrowingExample &#123; @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doRecoveryActions() &#123; // ... &#125; @AfterThrowing( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing="ex") public void doRecoveryActions(DataAccessException ex) &#123; // ... &#125;&#125; @AfterFinal 增强，不管是抛出异常或者是正常退出，该增强都会得到执行，一般用于释放资源，相当于 finally。使用 @After 声明 Final 增强，其拥有两个属性： vlaue：该成员用于定义切点。 argNames：如上所述 123456789import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.After;@Aspectpublic class AfterFinallyExample &#123; @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doReleaseLock() &#123; // ... &#125;&#125; @DeclareParents引介增强是一种比较特殊的增强类型，它不是在目标方法周围织入增强，而是为目标类创建新的方法和属性，所以引介增强的连接点是类级别的，而非方法级别的。通过引介增强可以为目标类添加一个接口的实现，即原来目标类未实现某个接口，通过引介增强可以为目标类创建实现某接口的代理。使用 @DeclareParents 声明引介增强，其拥有两个属性： vlaue：该成员用于定义切点，它表示在哪个目标类上添加引介增强。 defaultImpl：默认的接口实现类。 示例：给定一个接口 UsageTracked 以及该接口的实现 DefaultUsageTracked，vlaue 属性指向需要添加接口实现的类，defaultImpl 属性指向默认的接口实现类。通过 @DeclareParents 为 value 属性的 AspectJ 切点表达式语法所匹配的类添加一个需要实现的 UsageTracked 接口，并指定其默认实现类为 DefaultUsageTracked，然后通过切面技术将 DefaultUsageTracked 融合到 value 属性的 AspectJ 切点表达式语法所匹配的类，这样 value 属性的 AspectJ 切点表达式语法所匹配的类就实现了 UsageTracked 接口了。123456789@Aspectpublic class UsageTracking &#123; @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount(); &#125;&#125; 1interface UsageTracked &#123;&#125; 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（六）—— IOC 容器之不同的配置方式]]></title>
      <url>%2F2016%2F11%2F18%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%E4%B8%8D%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[基于注解的配置XML 设置的替代方法是基于注释的配置，它依赖于字节码元数据来连接组件而不是角括号声明。开发人员通过使用相关类，方法或字段声明上的注释来将配置移动到组件类本身中，而不是使用 XML 来描述 bean 布线。例如，Spring2.0 引入了使用 @Required 注释实现 required 属性的可能性。Spring2.5 添加了对 JSR-250 注释的支持，例如 @PostConstruct 和 @PreDestroy。Spring3.0 增加了对 javax.inject 包中包含的 JSR-330（Java的依赖注入）注释的支持，例如 @Inject 和 @Named。 @required@Required 注释适用于 bean 属性的 setter 方法，此注释表示被标注的 bean 属性必须在配置时通过 bean 定义中的显式属性值或通过自动装配被填充，如果被标注的 bean 属性未被填充，容器将抛出异常。如下例子所示：12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Required public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; @AutowiredSpring 通过 @Autowired 注解实现 Bean 的依赖注入，可以运用在多种自动注入场景。 应用于构造函数Spring 框架4.3，如果目标 bean 只定义了一个构造函数，则可以不需要 @Autowired。如果有多个构造函数，则至少必须为其中一个声明注解，告知容器哪一个是必须被使用的。12345678public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; 应用于 setter 方法12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; 应用于拥有参数的某个方法12345678910public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; 应用于字段或与构造函数混合使用12345678910public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired private MovieCatalog movieCatalog; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; 应用于数组或集合123456789101112131415public class MovieRecommender &#123; @Autowired private MovieCatalog[] movieCatalogs; private Set&lt;MovieCatalog&gt; movieCatalogs; @Autowired public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs; &#125; private Map&lt;String, MovieCatalog&gt; movieCatalogs; @Autowired public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs; &#125; // ...&#125; 应用于泛型原始类：1234567891011@Configurationpublic class MyConfiguration &#123; @Bean public StringStore stringStore() &#123; return new StringStore(); &#125; @Bean public IntegerStore integerStore() &#123; return new IntegerStore(); &#125;&#125; 泛型类：1234567891011@Configurationpublic class MyConfiguration &#123; @Autowired private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean @Autowired private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean // Inject all Store beans as long as they have an &lt;Integer&gt; generic // Store&lt;String&gt; beans will not appear in this list @Autowired private List&lt;Store&lt;Integer&gt;&gt; s;&#125; required 属性如果容器中没有一个和标注变量类型匹配的 Bean，Spring 容器启动时会抛出异常，默认情况下，required 属性值为 true，即要求一定要找到匹配的 Bean。12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired(required=false) public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; @Primary因为按类型自动装配可能导致多个候选项，所以通常需要对选择过程有更多的控制。@Primary 表示当多个 bean 自动装配到单值依赖关系的候选项时，应该优先选择 @Primary 指定的 bean。如果候选项中只有一个 primary bean，那么它将作为自动装配的值。如下定义 firstMovieCatalog 作为 primary MovieCatalog：123456789@Configurationpublic class MovieConfiguration &#123; @Bean @Primary public MovieCatalog firstMovieCatalog() &#123; ... &#125; @Bean public MovieCatalog secondMovieCatalog() &#123; ... &#125; // ...&#125; @Qualifier@Qualifier 可以将限定符值与特定参数相关联，缩小类型匹配集，以便为每个参数选择特定的 bean。如果容器中有一个以上匹配的 Bean 时，则可以通过 @Qualifier 注解限定 Bean 的名称。123456public class MovieRecommender &#123; @Autowired @Qualifier("main") private MovieCatalog movieCatalog; // ...&#125; @Qualifier 也可以用于独立的构造函数参数或方法参数：1234567891011public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(@Qualifier("main")MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; @Resource@Resource 要求提供一个 Bean 名称的属性，如果没有明确指定名称，则默认名称派生自字段名称或 setter 方法。在字段的情况下，它采用字段名称; 在 setter 方法的情况下，它接受 bean 属性名称。1234567public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource(name="myMovieFinder") public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 以下示例使用名称为 movieFinder 的 bean 注入到其 setter 方法中：1234567public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; @Autowired 默认按类型匹配注入 Bean，@Resource 则按名称匹配注入 Bean，@Inject 和 @Autowired 一样按类型匹配注入 Bean，只不过它没有 required 属性。 @PostConstruct 和 @PreDestroy使用 &lt;bean&gt; 进行配置时，可以通过 init-method 和 destory-method 属性指定 Bean 的初始化及容器销毁前执行的方法。Spring 从 2.5 开始支持 JSR-250 中定义的 @PostConstruct 和 @PreDestroy 注解，在 Spring 中相当于 init-method 和 destory-method 属性的功能，不过使用注解时，可以在一个 Bean 中定义多个 @PostConstruct 和 @PreDestroy 方法。12345678910public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; 基于 Java 类的配置@Bean 注解用于表示方法实例化，配置和初始化一个由 Spring IoC 容器管理的新对象。@Bean 注释与 &lt;bean/&gt; 元素具有相同的作用。@Configuration 注解表示被标注的 POJO 类可以为 Spring 容器提供 Bean 定义的信息。简单的实例如下：1234567@Configurationpublic class AppConfig &#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 与 AppConfig 类等同的 XML 配置：123&lt;beans&gt; &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;&lt;/beans&gt; @Bean@Bean 是一个方法级别的注解和 XML &lt;bean/&gt; 元素的替代，它支持 init-method, destroy-method, autowiring 和 name 等 &lt;bean/&gt; 提供的属性。1234567891011121314151617181920212223public class Foo &#123; public void init() &#123; // initialization logic &#125;&#125;public class Bar &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = "init") public Foo foo() &#123; return new Foo(); &#125; @Bean(destroyMethod = "cleanup") public Bar bar() &#123; return new Bar(); &#125;&#125; @Scope用于指定 Bean 的作用域。12345678@Configurationpublic class MyConfiguration &#123; @Bean @Scope("prototype") public Encryptor encryptor() &#123; // ... &#125;&#125; 自定义 Bean 的名称，别名和描述Bean 可以通过 name 属性自定义名称，当有多个名称时，其它的为别名；还可以使用 @Description 定义 Bean 的描述信息。123456789@Configurationpublic class AppConfig &#123; @Bean(name = &#123; "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" &#125;) @Description("Provides a basic example of a bean") public DataSource dataSource() &#123; // instantiate, configure and return DataSource bean... return new DataSource(); &#125;&#125; @Configuration@Configuration 是一个类级别的注解，表示该类是为 Spring 容器提供 bean 定义信息的类。 @Import等同于 XML 配置中的 &lt;import/&gt; 元素，@Import 注解允许从另一个 Configuration 类中加载 @Bean 定义。12345678910111213141516@Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123; @Bean public B b() &#123; return new B(); &#125;&#125; 如上所述，ConfigB 中导入了 ConfigA，所以在实例化上下文的时候，只需要提供 ConfigB。123456public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); // now both beans A and B will be available... A a = ctx.getBean(A.class); B b = ctx.getBean(B.class);&#125; @ImportResource用于加载资源文件路径的注解。 properties-config.xml 123&lt;beans&gt; &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;&lt;/beans&gt; jdbc.properties 123jdbc.url=jdbc:hsqldb:hsql://localhost/xdbjdbc.username=sajdbc.password= bean 类 1234567891011121314@Configuration@ImportResource("classpath:/com/acme/properties-config.xml")public class AppConfig &#123; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean public DataSource dataSource() &#123; return new DriverManagerDataSource(url, username, password); &#125;&#125; main 类 12345public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); TransferService transferService = ctx.getBean(TransferService.class); // ...&#125; 不同配置方式的比较 描述 基于 XML 配置 基于注解配置 基于 Java 类配置 Bean 定义 在 XML 文件中通过 &lt;bean&gt; 元素定义 Bean。如：&lt;bean class=&quot;com.lake.UserDao&quot;/&gt; 在 Bean 实现类出通过标注 @Component 或衍型类（@Repository、@Service 及 @Controller）定义 Bean 在标注了 @Configuration 的 Java 类中，通过在类方法上标注 @Bean 定义一个 Bean，方法必须提供 Bean 的实例化逻辑 Bean 名称 通过 &lt;bean&gt; 的 id 或 name 属性定义 Bean。如：&lt;bean id=&quot;userDao&quot; class=&quot;com.lake.UserDao&quot;/&gt;，默认名称为：com.lake.UserDao#0 通过注解的 value 属性定义，如 @Component(“userDao”)，默认名称为小写字母开头的类名（不带包名）：userDao 通过 @Bean 的 name 属性定义，如 @Bean(“userDao”)，默认名称为方法名 Bean 注入 通过 &lt;property&gt; 子元素或通过 p 命名空间的动态属性，如 p:userDao-ref=”userDao” 进行注入 通过在成员变更或方法入参处标注 @Autowired，按类型匹配自动注入，还可以配合使用 @Qualifier 按名称匹配方式注入 比较灵活，可以通过在方法处通过 @Autowired 使方法入参绑定 Bean，然后在方法中通过代码进行注入，还可通过调用配置类的 @Bean 方法进行注入 Bean 作用域 通过 &lt;bean&gt; 的 scpoe 属性指定，如：&lt;bean class=&quot;com.lake.UserDao&quot; scope=&quot;prototype&quot;/&gt; 通过在类定义处标注 @Scope 指定，如：@Scope(“prototype”) 通过在 Bean 方法定义处标注 @Scope 指定 Bean 生命周期方法 通过 &lt;bean&gt; 的 init-method 和 destroy-method 属性指定 Bean 实现类的方法名，最多只能指定一个初始化方法和销毁方法 通过在目标方法上标注 @PostConstruct 和 @PreDestory 注解指定初始化或销毁方法，可以定义任意多个 通过 @Bean 的 initMethod 或 destoryMethod 指定一个初始化或销毁方法。对于初始化方法来说，可以直接在方法内部通过代码的方式灵活定义初始化逻辑 Bean 延迟初始化 通过 &lt;bean&gt; 的 lazy-init 属性指定，默认为 default，继承自 &lt;beans&gt; 的 default-lazy-init 设置，该值默认为 false 通过在类定义出标注 @Lazy 指定，如：@Lazy(true) 通过在 Bean 方法定义出标注 @Lazy 指定 适合场景 Bean 实现类来源于第三方类库，如 DataSource、JdbcTemplate 等，因无法在类中标注注解，通过 XML 配置方式较好；命名空间的配置，如 aop、context 等，只能采用基于 XML 的配置 Bean 的实现类时当前项目开发的，可以直接在 Java 类中使用基于注解的配置 优势在于可以通过代码的方式控制 Bean 初始化的整体逻辑，所以如果实例化 Bean 的逻辑比较复杂，则比较适合用基于 Java 类配置的方式 ｜ 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（五）—— IOC 容器之依赖注入]]></title>
      <url>%2F2016%2F11%2F17%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
      <content type="text"><![CDATA[Spring 支持两种依赖注入方式，分别为构造函数注入和属性注入，此外还支持工厂方法注入方式。 构造函数注入构造函数注入由容器调用带参的构造函数来完成，与通过调用指定参数的静态工厂方法来构造 bean 相似。包含构造函数的类是一个没有依赖于容器指定的接口，基类或注释的 POJO，如下所示：123456789public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on a MovieFinder private MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 构造函数参数解析使用参数的类型进行构造函数参数解析匹配。如果 bean 定义的构造函数参数不存在歧义，那么构造函数参数在 &lt;beans/&gt; 中定义的参数顺序和 bean 被实例化时提供给适当的构造函数的参数顺序一致。123456package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ... &#125;&#125; 12345678&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;/bean&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt;&lt;/beans&gt; 按类型匹配入参在 &lt;constructor-arg&gt; 的元素中有一个 type 属性，它为 Spring 提供了判断配置项和构造函数入参对应关系的信息。Spring 的配置文件采用和元素标签顺序无关的策略，在一定程度上保证配置信息的正确性，&lt;constructor-arg&gt; 位置的改变并不会对最终的配置产生影响。123456789101112package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="7500000"/&gt; &lt;constructor-arg type="java.lang.String" value="42"/&gt;&lt;/bean&gt; 按索引匹配入参如果构造函数两个入参的类型相同，仅通过 type 无法确定对应关系，需要通过入参索引的方式进行确定，参数和构造函数参数需要顺序对应。1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="7500000"/&gt; &lt;constructor-arg index="1" value="42"/&gt;&lt;/bean&gt; 按参数名匹配入参使用 @ConstructorProperties 注解指定入参名，在 xml 文件中通过参数名的方式匹配入参。123456789package examples;public class ExampleBean &#123; // Fields omitted @ConstructorProperties(&#123;"years", "ultimateAnswer"&#125;) public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg name="years" value="7500000"/&gt; &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;&lt;/bean&gt; 属性注入属性注入即通过 setXxx() 方法注入 Bean 的属性值或依赖对象，由于属性注入方式具有可选择性和灵活性高的优点，因此属性注入是实际应用中最常见的注入方式。属性注入要求 Bean 提供一个默认的构造函数，并为需要注入的属性提供对应的 Setter 方法。Spring 先调用 Bean 的默认构造函数实例化 Bean 对象，然后通过反射的方式调用 Setter 方法注入属性值。1234567891011121314package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public void setYears(int years) &#123; this.years = years; &#125; public void setUltimateAnswer(int ultimateAnswer) &#123; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;property name="years"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/property&gt; &lt;property name="ultimateAnswer"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; 注入参数详解字面值字面值指可用字符串表示的值，且这些值可通过 value 属性进行注入。Spring 容器在内部为字面值提供了编辑器，它可以将以字符串表示的字面值转换为内部变量的相应类型。1234567&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="masterkaoli"/&gt;&lt;/bean&gt; 使用 p-namespace 简化上述的 xml 配置：123456&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="root" p:password="masterkaoli"/&gt; 引用其他 bean使用 ref 指定引用的 bean：1234&lt;!-- in the parent context --&gt;&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt;&lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt; 12345678&lt;!-- in the child (descendant) context --&gt;&lt;!-- bean name is the same as the parent bean --&gt;&lt;bean id="accountService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target"&gt; &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt; &lt;/property&gt; &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt; 内部 Bean内部 Bean 和 Java 代码中匿名内部类相似，没有名字，也不能被其他 Bean 引用，只能在声明出为外部 Bean 提供实例注入。内部 Bean 即使提供了 id、name、scope 属性，也会被忽略，scope 默认为 prototype类型。123456789&lt;bean id="outer" class="..."&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name="target"&gt; &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt; &lt;property name="name" value="Fiona Apple"/&gt; &lt;property name="age" value="25"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 集合类型属性在 , , , 和 元素中，可以设置属性和 Java 集合类型 List, Set, Map 和 Properties 的参数。12345678910111213141516171819202122232425262728293031&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt; &lt;prop key="support"&gt;support@example.org&lt;/prop&gt; &lt;prop key="development"&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name="someList"&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name="someMap"&gt; &lt;map&gt; &lt;entry key="an entry" value="just some string"/&gt; &lt;entry key ="a ref" value-ref="myDataSource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name="someSet"&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 集合合并允许子 &lt;bean&gt; 继承父 &lt;bean&gt; 的同名属性集合元素，并将子 &lt;bean&gt; 中配置的集合属性值和父 &lt;bean&gt; 中配置的同名属性值合并起来作为最终 Bean 的属性值。12345678910111213141516171819&lt;beans&gt; &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="child" parent="parent"&gt; &lt;property name="adminEmails"&gt; &lt;!-- the merge is specified on the child collection definition --&gt; &lt;props merge="true"&gt; &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;beans&gt; 强类型集合JDK5.0 提供了强类型集合的新功能，允许为集合元素指定类型。123456public class Foo &#123; private Map&lt;String, Float&gt; accounts; public void setAccounts(Map&lt;String, Float&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 1234567891011&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="accounts"&gt; &lt;map&gt; &lt;entry key="one" value="9.99"/&gt; &lt;entry key="two" value="2.75"/&gt; &lt;entry key="six" value="3.99"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; null 值和空 string 值参数值为空 String：123&lt;bean class="ExampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt; 参数值为 null：12345&lt;bean class="ExampleBean"&gt; &lt;property name="email"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; 简化配置方式Spring 为字面值、引用 Bean 和集合都提供了简化的配置方式。 使用 p-namespace1234567891011&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean name="classic" class="com.example.ExampleBean"&gt; &lt;property name="email" value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;bean name="p-namespace" class="com.example.ExampleBean" p:email="foo@bar.com"/&gt;&lt;/beans&gt; 使用 c-namespace12345678910111213141516&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt; &lt;!-- traditional declaration --&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;constructor-arg value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;!-- c-namespace declaration --&gt; &lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com"/&gt;&lt;/beans&gt; 级联属性123&lt;bean id="foo" class="foo.Bar"&gt; &lt;property name="fred.bob.sammy" value="123" /&gt;&lt;/bean&gt; foo bean 有一个 fred 属性，在 fred 下有一个 bob 属性， 在 bob 下有一个 sammy 属性。 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（四）—— IOC 容器之 Bean 的生命周期]]></title>
      <url>%2F2016%2F11%2F16%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[Initialization 回调org.springframework.beans.factory.InitializingBean 接口允许 bean 在容器设置完所有属性后执行初始化工作，初始化工作在实现 InitializingBean 的类中的 afterPropertiesSet() 方法中执行。此外，初始化工作也可通过 @PostConstruct 注解来指定执行初始化工作的方法；或者指定一个 POJO 的初始化方法，然后在 XML 文件中使用 init-method 属性指定在该方法中执行初始化操作。 实现 InitializingBean 接口1&lt;bean id="exampleInitBean" class="examples.ExampleBean"/&gt; 12345public class ExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 使用 @PostConstruct 注解123456public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125;&#125; 使用 init-method 属性1&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt; 12345public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125; Destroy 回调org.springframework.beans.factory.DisposableBean 接口允许 bean 使用销毁回调，销毁工作在实现 DisposableBean 的类中的 destroy() 方法中执行。注解方法使用 @PreDestroy，XML 文件指定 destroy-method 属性即可。 实现 InitializingBean 接口1&lt;bean id="exampleInitBean" class="examples.ExampleBean"/&gt; 12345public class ExampleBean implements InitializingBean &#123; public void destroy() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 使用 @PostConstruct 注解123456public class CachingMovieLister &#123; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; 使用 init-method 属性1&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt; 12345public class ExampleBean &#123; public void cleanup() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 默认的 initialization 和 destroy 方法当做 initialization 和 destroy 工作时，使用 init(), initialize(), dispose() 等类似的方法名有助于我们识别方法的作用。每次我们都需要为每个 bean 设置 init-method 或 destroy-method 属性指定生命周期的回调方法，有一个更加简便的方法，即在 元素中使用 default-init-method 属性指定初始化的方法，则默认 元素下的所有 bean 的初始化方法均为 init()。12345&lt;beans default-init-method="init"&gt; &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt; &lt;property name="blogDao" ref="blogDao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112public class DefaultBlogService implements BlogService &#123; private BlogDao blogDao; public void setBlogDao(BlogDao blogDao) &#123; this.blogDao = blogDao; &#125; // this is (unsurprisingly) the initialization callback method public void init() &#123; if (this.blogDao == null) &#123; throw new IllegalStateException("The [blogDao] property must be set."); &#125; &#125;&#125; default-destroy-method 属性的使用方法也和 default-init-method 一样。 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（三）—— IOC 容器之 BeanFactory 和 ApplicationContext]]></title>
      <url>%2F2016%2F11%2F13%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%20BeanFactory%20%E5%92%8C%20ApplicationContext%2F</url>
      <content type="text"><![CDATA[简介BeanFactory 是 Spring 框架最核心的接口，它提高了高级 IOC 的配置机制。BeanFactory 使管理不同类型的 Java 对象成为可能，ApplicationContext 建立在 BeanFactory 的基础之上，提供了更多面向应用的功能，提供了国际化支持和框架事件体系，更易于创建实际应用。BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身，ApplicationContext 面向使用 Spring 框架的开发者。 BeanFactoryBeanFactory 提供了 Spring IOC 的基础功能，但它只能在第三方框架中直接使用。和 BeanFactory 相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，仍然存在于 Spring 中用于与 Spring 集成的大量第三方框架向后兼容的作用。BeanFactory 通常使用在运行于资源有限（内存消耗严重）的嵌入式应用中。 使用 BeanFactory 实现注册一个后处理器（PostProcessor）： 123456DefaultListableBeanFactory factory = new DefaultListableBeanFactory();// populate the factory with bean definitions// now register any needed BeanPostProcessor instancesMyBeanPostProcessor postProcessor = new MyBeanPostProcessor();factory.addBeanPostProcessor(postProcessor);// now start using the factory 使用 BeanFactory 实现注册一个 BeanFactoryPostProcessor： 12345678DefaultListableBeanFactory factory = new DefaultListableBeanFactory();XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));// bring in some property values from a Properties filePropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();cfg.setLocation(new FileSystemResource("jdbc.properties"));// now actually do the replacementcfg.postProcessBeanFactory(factory); ApplicationContextApplicationContext 继承自 BeanFactory，提供了更多面向实际应用的功能。在 BeanFactory 中，很多功能需要以编程的方式实现，而在 ApplicationContext 中则可以通过配置的方式实现。 下图为 ApplicationContext 的继承体系图： ApplicationContext 的主要实现类是 ClassPathXmlApplicationContext，FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext，第一个默认从类路径加载配置文件，第二个默认从文件系统中装载配置文件，第三个可直接传入注解类，通过 register(Class…) 注册类或 scan(String…) 扫描路径 classpath 逐个注册类。 如上图所示，ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此之上还通过其他的接口扩展了 BeanFactory 的功能。这类接口包括： ApplicationEventPublisher：让容器拥有发布 ApplicationContext 事件的功能，包括容器启动时间、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件，并对事件进行响应处理。在 ApplicationContext 抽象实现类 AbstractApplicationContext 中，可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生 ApplicationContext 事件时通知这些事件监听者。 MessageSource：为应用提供 i18n 国际化消息访问的功能。 ResourcePatternResolver：所有 ApplicationContext 实现类都实现了通过 Ant 风格的资源文件路径装载 Spring 的配置文件。 Lifecycle：该接口于 Spring2.0 加入，提供了 start() 和 stop() 两个方法，主要用于控制异步处理过程。具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现，ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。 ConfigurableApplicationContext 继承自 ApplicationContext，增加了两个主要的方法：refresh() 和 close()，让 ApplicationContext 具有启动、刷新和关闭上下文的能力。在 ApplicationContext 关闭时，调用 refresh 可启动 ApplicationContext；在启动状态下调用，则清除缓存并重新装载配置信息。调用 close 关闭 ApplicationContext。 ApplicationContext 的初始化：ApplicationContext 在实例化后和 BeanFactory 一样调用 getBean(beanName) 返回 Bean；在初始化时，BeanFactory 初始化容器时并未实例化 Bean 直至第一次访问 Bean，ApplicationContext 在初始化上下文时实例化所有单实例的 Bean。和基于 XML 文件配置方式的相比，类注解的配置方式可以很容易地让开发者控制 Bean 的初始化过程。 配置文件在类路径下，优先使用 ClassPathXmlApplicationContext，“com/example/context/beans.xml” 等同于 “classpath:com/example/context/beans.xml”： 1234ApplicationContext ctx = new ClassPathXmlApplicationContext("com/example/context/beans.xml");ApplicationContext ctx = new ClassPathXmlApplicationContext( new String[]&#123; "com/beans1.xml", "com/beans2.xml" &#125;); 配置文件在类路径下，优先使用 FileSystemXmlApplicationContext，“com/example/context/beans.xml” 等同于 “file:com/example/context/beans.xml”： 12ApplicationContext ctx = new FileSystemXmlApplicationContext("com/example/context/beans.xml"); 需要解析的是注解类，使用 AnnotationConfigApplicationContext： Bean 类： 1234567891011121314151617181920package com.lake.context;public class Car &#123; private String brand; private int maxSpeed; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125;&#125; 带注解的 POJO 类： 12345678910111213package com.lake.context;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class Beans &#123; @Bean(name = "car") public Car buildCar() &#123; Car car = new Car(); car.setBrand("奔驰"); car.setMaxSpeed(300); return car; &#125;&#125; 通过带 @Configuration 的 POJO 类启动容器： 12345678910package com.lake.context;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class AnnotationApplicantionContext &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(Beans.class); Car car = context.getBean("car", Car.class); car.getBrand(); &#125;&#125; WebApplicationContextWebApplicationContext 为 Web 应用而准备，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。Spring 提供了工具类 WebApplicationContextUtils，通过 getWebApplicationContext(ServletContext sc) 获取 WebApplicationContext 实例。 ConfigurableWebApplicationContext 继承自 WebApplicationContext，它允许通过配置的方式实例化 WebApplicationContext，它有两个重要的方法： setServletContext(ServletContext servletContext)：为 Spring 设置 WebApplicationContext。 setConfigLocations(String[] configLocations)：设置 Spring 配置文件地址，相对于 Web 根目录，如 /WEB-INF/lake-dao.xml，/WEB-INF/lake-service.xml 等。但用户也可使用带资源类型前缀的地址，如 classpath:com/example/context/beans.xml 等。 WebApplicationContext 初始化WebApplicationContext 需要 ServletContext 实例，它必须在拥有 Web 容器的情况下才能完成启动工作，和通常的 Web 开发类似，在 web.xml 中配置自启动的 Servlet 或容器监听器（ServletContextListener），即可完成启动 Spring WebApplicationContext 的工作。Spring 提供了用于启动 WebApplicationContext 的 Servlet 和 Web 容器监听器： org.springframework.web.context.ContextLoaderServlet org.springframework.web.context.ContextLoaderListener 两者都实现了启动 WebApplicationContext 实例的逻辑，只要根据 Web 容器的具体情况选择其一，并在 web.xml 中完成配置即可。 ContextLoaderListener 启动 WebApplicationContext:123456789&lt;!-- 指定配置文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 设置Web容器监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 在不支持容器监听器的低版本 Web 容器中，使用 ContextLoaderServlet：1234567891011&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 声明自启动的Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springContextLoaderServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;!-- 启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 标准和自定义事件ApplicationContext 通过 ApplicationEvent 和 ApplicationListener 接口提供事件处理，当某个 bean 实现了 ApplicationListener 接口时，当 ApplicationEvent 发布给 ApplicationContext 时，该 bean 会被告知。 标准事件 ContextRefreshedEvent：当 ApplicationContext 被初始化或刷新时发布事件。这里的初始化是指所有的 beans 被加载，后处理器 beans 被检测并激活，单例被预实例化，ApplicationContext 对象已准备好并可用。当上下文关闭时，refresh 可以被多次触发，这样的 ApplicationContext 支持热刷新。XmlWebApplicationContext 支持热刷新，而 GenericApplicationContext 不支持。 ContextStartedEvent：ApplicationContext 被启动时发布事件，使用 ConfigurableApplicationContext 接口的 start() 方法。这里的启动意味着 beans 接收一个显式的启动信号，该信号用于在显式的停止之后重新启动 beans，也可以用于启动没有被配置成自动启动的组件。 ContextStoppedEvent：ApplicationContext 被停止时发布事件，使用 ConfigurableApplicationContext 接口的 stop() 方法。 RequestHandledEvent：告知所有 beans 一个 HTTP 请求已被处理的特定的 web 事件，当请求完成时事件将会被发布，该事件只能通过 Spring 的 DispatcherServlet 应用于 Web 应用中。 自定义事件自定义事件需要继承 Spring 的 ApplicationEvent 基类：12345678910public class BlackListEvent extends ApplicationEvent &#123; private final String address; private final String test; public BlackListEvent(Object source, String address, String test) &#123; super(source); this.address = address; this.test = test; &#125; // accessor and other methods...&#125; 调用 ApplicationEventPublisher 的 publishEvent() 方法发布自定义的 ApplicationEvent，该类需要实现 ApplicationEventPublisherAware 接口并作为 bean 来注册。在配置期间，Spring 容器会检测到实现了 ApplicationEventPublisherAware 接口的 EmailService 并自动的调用 setApplicationEventPublisher() 方法。123456789101112131415161718public class EmailService implements ApplicationEventPublisherAware &#123; private List&lt;String&gt; blackList; private ApplicationEventPublisher publisher; public void setBlackList(List&lt;String&gt; blackList) &#123; this.blackList = blackList; &#125; public void setApplicationEventPublisher(ApplicationEventPublisher publisher) &#123; this.publisher = publisher; &#125; public void sendEmail(String address, String text) &#123; if (blackList.contains(address)) &#123; BlackListEvent event = new BlackListEvent(this, address, text); publisher.publishEvent(event); return; &#125; // send email... &#125;&#125; 创建一个实现 ApplicationListener 接口的类，并作为 bean 来注册，以此接受自定义的 ApplicationEvent。123456789public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; &#123; private String notificationAddress; public void setNotificationAddress(String notificationAddress) &#123; this.notificationAddress = notificationAddress; &#125; public void onApplicationEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress... &#125;&#125; 下面的代码用于配置和注册上述的类：123456789101112&lt;bean id="emailService" class="example.EmailService"&gt; &lt;property name="blackList"&gt; &lt;list&gt; &lt;value&gt;known.spammer@example.org&lt;/value&gt; &lt;value&gt;known.hacker@example.org&lt;/value&gt; &lt;value&gt;john.doe@example.org&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="blackListNotifier" class="example.BlackListNotifier"&gt; &lt;property name="notificationAddress" value="blacklist@example.org"/&gt; &lt;/bean&gt; 当 emailService 的 sendEmail() 方法被调用时，如果有任何邮件需要被加入黑名单，那么自定事件 BlackListEvent 会被发布。blackListNotifier bean 被注册作为 ApplicationListener 并接收 BlackListEvent。 基于注解的事件监听器12345678910public class BlackListNotifier &#123; private String notificationAddress; public void setNotificationAddress(String notificationAddress) &#123; this.notificationAddress = notificationAddress; &#125; @EventListener public void processBlackListEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress... &#125;&#125; 异步监听器12345@EventListener@Asyncpublic void processBlackListEvent(BlackListEvent event) &#123; // BlackListEvent is processed in a separate thread&#125; 顺序监听器12345@EventListener@Order(42)public void processBlackListEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress...&#125; 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（二）—— 基本概念的理解]]></title>
      <url>%2F2016%2F11%2F12%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[控制反转（IOC）控制反转（Inversion of Control），即依赖注入（Dependency Injection），它们两个是一个东西的两种不同的说法。依赖注入是一个程序设计模式和架构模型，是控制反转的特殊实现，它指一个对象应用另外一个对象来提供一个特殊的能力。IOC 是 Spring 的核心，理解它的时候可以分为控制和反转两步来理解。举个例子：你现在接到一份工作，但是你没空，你把工作交给你的好友来完成，你对工作如何完成已不关心，控制权移交到你的好友手中，他可以决定如何完成工作，你只需要等待结果即可。如上所述，控制即对工作的控制权，反转可理解为原先你所掌握的工作的控制权移交到好友身上。在 Spring 中理解为某一接口具体实现类的控制权从调用类中移除，转而由第三方控制（类似对成员变量的赋值的控制权从代码移交到 xml 配置文件中）。依赖注入理解为让调用者对某一接口实现类的依赖关系由第三方（容器或协助类）注入，以移除调用类对某一接口实现类的依赖。 面向切面编程（AOP）面相切面编程（AOP）是对面相对象编程（OOP）的补充，OOP 主要的模块单元是 class (类)，而 AOP 是 aspect（切面），切面使得诸如事务管理等跨越多个类型和对象的关注点模块化。AOP 通过横向抽取机制，为无法通过纵向继承体系进行抽象的类的重复性代码提供了解决方案。 连接点（Join point）在程序执行过程中具有边界性质的特定点，比如某个类初始化前后、类的某个方法调用前后或者处理异常的时候。在 Spring AOP 中，一个连接点总是代表一个方法的执行。 增强（Advice）在切面的某个特定的连接点上执行的动作。增强有各种类型，其中包括 around、before 和 after 等。Spring 以拦截器作增强模型，并维护一个以连接点为中心的拦截器链。 切点（Pointcut）用来匹配连接点的断言。增强关联一个切点表达式，并在匹配这个切入点的连接点上运行。AOP 通过切点定位特定的连接点：Spring 默认使用切点语法 AspectJ。通过数据库查询的概念来理解切点和连接点：连接点相当于数据库中的记录，而切点相当于查询条件，一个切点可以匹配多个连接点。 切面（Aspect）切面由切点和增强组成，包括横切逻辑和连接点的定义。在 Spring AOP 中，切面可以使用通用类（schema-based 基于模式的风格）或者在普通类中以 @Aspect 注解（@AspectJ 注解样式）来实现。 引介（Introduction）引介是一种特殊的增强，它为类添加一些属性和方法。一个业务类原先没有实现某个接口，通过 AOP 的引介功能，可以动态地为该业务添加接口的实现逻辑，让业务类成为该接口的实现类。例如：使用一个引介来使 bean 实现 IsModified 接口，以便简化缓存机制。 目标对象（Target object）被一个或多个切面所增强的对象。因为 Spring AOP 是使用运行时代理来实现的，所以这个对象总是一个代理对象。 代理（Proxy）一个类被 AOP 织入增强后，就生成一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。在 Spring 中，AOP 代理可以是 JDK 动态代理或者 CGLIB 代理。 织入（Weaving） 织入是将增强添加到目标类具体连接点上的过程。AOP 有三种织入方式： 编译期织入，要求特殊的 Java 编译器 类装载期织入，要求使用特殊的类装载器 动态代理织入，在运行期为目标类添加增强生成子类的方式 Spring 采用动态代理织入（即在运行时完成织入），而 AspectJ 采用编译期和类装载期织入。 Spring 框架组件列表 GroupId ArtifactId 描述 org.springframework spring-aop 支持基于代理的 AOP org.springframework spring-aspects 基于 AspectJ 的切面 org.springframework spring-beans 包含 Groovy 的 Beans 支持 org.springframework spring-context 应用程序上下文运行时，包括调度和远程抽象 org.springframework spring-context-support 支持将常见的第三方库集成到 Spring 应用程序上下文的类中 org.springframework spring-core Spring 核心，为其它模块所用 org.springframework spring-expression Spring 表达式（SpEL） org.springframework spring-instrument JVM 引导用的代理工具 org.springframework spring-instrument-tomcat Tomcat 的代理工具 org.springframework spring-jdbc JDBC 支持包，包括 DataSource 设置和 JDBC 访问支持 org.springframework spring-jms JMS 支持包，包括用于发送和接收 JMS 消息的帮助类 org.springframework spring-messaging 支持消息架构和协议 org.springframework spring-orm 对象/关系映射，包含对 JPA 和 Hibernate 支持 org.springframework spring-oxm 对象/XML映射 org.springframework spring-test 支持单元测试和集成测试的 Spring 组件 org.springframework spring-tx 事务基础设施，包括 DAO 支持和 JCA 集成 org.springframework spring-web Web 支持包，包括客户端和 Web 远程处理 org.springframework spring-webmvc REST Web 服务和 Web 应用程序实现的 model-view-controller org.springframework spring-webmvc-portlet MVC 实现在 Portlet 环境中的使用 org.springframework spring-websocket WebSocket 和 SockJS 实现，包含 STOMP 支持 参考资料：中文翻译《Spring Framework 4.x参考文档》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（一）—— 版本新特性]]></title>
      <url>%2F2016%2F11%2F12%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[1. spring 2.0 和 2.5 的新特性1.1 简介JDK 版本要在 1.4.2 以上，Java 5 和 Java 6 都支持。Spring 框架继续保持对 Java EE 1.3 及以后版本的兼容，完全支持 Java EE 5。对服务器（应用服务器和Web服务器）的支持： WebLogic：8.1、9.0、9.2、10 WebSphere：5.1、6.0、6.1 OC4J(Oracle)：10.1.3、11 JBoss：3.2、4.0、4.2 Tomcat：4.1、5.0、5.5、6.0 Jetty：4.2、5.1、6.1 Resin：2.1、3.0、3.1 GlassFish：v1、v2 1.2 控制反转（IOC）容器1.2.1 新的 bean 作用域Spring2.0：IoC 容器中只支持 singleton 和 prototype 两个不同的 bean 作用域。Spring2.5：还支持 request、session、global session 三个在 web 环境下使用的 bean 作用域，且提供了hooks，可以让用户创建自己的作用域。 1.2.2 更简单的 XML 配置Spring2.5 对 Spring2.0 的 DTD 进行了更新，spring-beans-2.0.dtd 可在发布包下的 dist/resources 下找到。12&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt; 1.2.3 可扩展的 XML 编写作为一个应用程序开发人员或第三方框架或产品的供应商，开发自定义标签，供其他开发人员把这些标签嵌入到自己的Spring配置文件里。 1.2.4 Annotation（注解）驱动配置Spring 2.0 引入了一些用于配置的 annotation, 包括 @Transactional, @Required, @PersistenceContext /@PersistenceUnit。Spring 2.5 引入了用于配置的完整的 Annotation 集合: @Autowired，以及对 JSR-250 注解 @Resource, @PostConstruct, @PreDestroy 的支持。 1.2.5 在 classpath 中自动搜索组件组件类会注解为 stereotype: @Component, @Repository, @Service, @Controller，取决于程序的上下文配置，这些组件会被自动搜索到，并且转变为 Spring bean 定义，而不需要为每个类都进行明确的配置。 1.3 面向切面编程（AOP）1.3.1 更加简单的 AOP XML 配置1.3.2 对 @AspectJ 切面的支持1.3.3 对 bean 命名 pointcut 的支持1.3.4 对 AspectJ 装载时织入的支持1.4 中间层1.4.1 在XML里更为简单的声明性事务配置Spring 2.5 支持方便的注解驱动的事务管理，通过 context:load-time-weaver 和 tx:annotation-driven mode=”aspectj” 的联合使用进行事务管理。 1.4.2 对 Websphere 事务管理的完整支持要自动探测底层的 JTA 事务平台，可以使用 Spring 2.5 的新 tx:jta-transaction-manager 配置元素。它会自动探测 BEA WebLogic 和 IBM WebSphere，注册正确的 PlatformTransactionManager。 1.4.3 JPASpring 2.5 对 OpenJPA 的支持升级到了 OpenJPA 1.0，支持 savepoint 这样的高级特性。 1.4.4 异步的JMS在 Spring 2.0 之前，Spring 的 JMS 的作用局限于发送消息和同步接收消息。Spring 2.0 提供对异步消息接收的完整支持。在 Spring 2.5 中， JCA 风格的异步消息监听器设置也通过 GenericMessageEndpointManager 工具得到了支持。 1.4.5 JDBC引入了新类，Spring 2.5 扩充了 SimpleJdbcTemplate 的功能，引入了 SimpleJdbcCall和 SimpleJdbcInsert 操作对象。 1.5 Web 层1.5.1 Spring MVC 合理的默认值1.5.2 Portlet 框架1.5.3 基于 Annotation 的控制器1.5.4 Spring MVC 的表单标签库1.5.5 对 Tiles 2，JSF 1.2，JAX-WS 支持2. spring 3.x 的新特性2.1 spring 3.02.1.1 Spring3.0 以后分成多个 jar 包 org.springframework.aop， 包含在应用中使用Spring的AOP特性时所需的类。 org.springframework.asm，Spring独立的asm程序，Spring2.5.6的时候需要 asm.jar 包，3.0开始提供自己独立的asm.jar org.springframework.aspects，提供对AspectJ的支持，以方便的将面向切面的功能集成进IDE中，比如Eclipse AJDT. org.springframework.beans，所有应用都要用到，它包含访问配置文件，创建和管理Bean以及进行反转共控制和依赖注入操作时所需的类 org.springframework.context，为 Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext 特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如 Velocity、 FreeMarker、 JasperReports 集成的类， 以及校验 Validation 方面的相关类。 org.springframework.context.support，包含支持缓存Cache（ehcache）JCA、JMX、邮件服务（Java Mail、Mail）COS、任务计划Scheduling（Timer、Quartz）方面的类。 org.springframework.core，包含 Spring 框架基本的核心工具类，Spring 其它组件要都要使用到这个包里的 类，是其它组件的基本核心。 org.springframework.expression，包含Spring 表达式语言相关的类，应用使用到SpEL时需要添加这个jar包。 org.springframework.instrument.tomcat，Spring3.0对Tomcat的连接池的集成。 org.springframework.instrument，Spring3.0 对服务器的代理接口。 org.springframework.jdbc，包含对 Spring 对 JDBC 数据访问进行封装的所有类。 org.springframework.jms，提供了对JMS1.0.2/1.1 的支持类。 org.springframework.orm，包含Spring对DAO特性集进行了扩展，使其支持iBATIS、JDO、OJB、TopLink，因+ 为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含 spring-dao.jar包。 org.springframework.oxm，Spring 对 Object/XMl 的映射支持,可以让Java与XML之间来回切换。 org.springframework.test，对Junit等测试框架的简单封装。 org.springframework.transaction，为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 org.springframework.web，包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 org.springframework.web.portlet，对SpringMVC的增强，包含SpringMVC相关的类 org.springframework.web.servlet，对J2EE6.0的Servlet3.0的支持。 org.springframework.web.struts，对Struts框架支持，可以更方便更容易的集成Struts框架。 2.1.2 新增特性 Spring 表达式语言 增强的 IOC 和基于 java 的 Bean 元数据 通用类型转换系统和字段格式 来自于 Srping Web Services 项目的对象和 XML 之间的映射 增强的 REST 支持 @MVC additions （Spring的 MVC 注解增强） 声明式模型验证 提前对 JEE6 的支持 嵌入式数据库的支持 2.1.3 基于 Java 5 的核心API的更新 BeanFactory接口尽可能的返回明确的实例： T getBean(Class requiredType) getBean(String name, Class requiredType) Map getBeansOfType(Class type) Spring 的 TaskExecutor 继承 java.util.concurrent.Executor 接口 扩展的子接口 AsyncTaskExecutor 支持标准的具有返回结果 Futures 的 Callables 基于 Java5 的 API 和 SPI 转换器 无状态的 ConversionService 和 Converters 取代标准的 JDK PropertyEditors 类型化的 ApplicationListener 2.1.4 Spring 表达式语言（简称SpEL）SpEL 使得 java 具有动态语言的风格，可以在运行时获取表达式的值。依赖注入时可以使用 SpEL 表达式语言, 不再只是原来简单的属性文件变量(xml)。示例： xml 配置： 123456&lt;bean class="mycompany.RewardsTestDatabase"&gt; &lt;property name="databaseName" value="#&#123;systemProperties.databaseName&#125;"/&gt; &lt;property name="keyGenerator" value="#&#123;strategyBean.databaseKeyGenerator&#125;"/&gt;&lt;/bean&gt; java 代码： 12345678@Repositorypublic class RewardsTestDatabase &#123; @Value("#&#123;systemProperties.databaseName&#125;") public void setDatabaseName(String dbName) &#123; ... &#125; @Value("#&#123;strategyBean.databaseKeyGenerator&#125;") public void setKeyGenerator(KeyGenerator kg) &#123; ... &#125;&#125; 2.1.5 增强的 IOC 和基于 java 的 bean 配置更多的注解的支持：@Configuration，@Bean，@DependsOn， @Primary，@Lazy，@Import，@ImportResource，@Value示例： xml 配置： 123&lt;context:component-scan base-package="org.example.config"/&gt;&lt;util:properties id="jdbcProperties" location="classpath:org/example/config/jdbc.properties"/&gt; 也可以使用如下代码来代替 xml 的配置： 12ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); FooService fooService = ctx.getBean(FooService.class); java 代码： 12345678910111213141516171819202122232425262728package org.example.config;...@Configurationpublic class AppConfig &#123; private @Value("#&#123;jdbcProperties.url&#125;") String jdbcUrl; private @Value("#&#123;jdbcProperties.username&#125;") String username; private @Value("#&#123;jdbcProperties.password&#125;") String password; @Bean public FooService fooService() &#123; return new FooServiceImpl(fooRepository()); &#125; @Bean public FooRepository fooRepository() &#123; return new HibernateFooRepository(sessionFactory()); &#125; @Bean public SessionFactory sessionFactory() &#123; // wire up a session factory AnnotationSessionFactoryBean asFactoryBean = new AnnotationSessionFactoryBean(); asFactoryBean.setDataSource(dataSource()); // additional config return asFactoryBean.getObject(); &#125; @Bean public DataSource dataSource() &#123; return new DriverManagerDataSource(jdbcUrl, username, password); &#125;&#125; 2.1.6 通用类型转换系统和字段格式化系统Spring3.0 加入了一个通用的类型转换系统，它被 SpEL 用作类型转换，并且可能被一个 Spring 容器使用，用于当绑定 bean 的属性值时进行类型转换。此外还增加了一个字段格式化系统，它提供了更简单且强大的功能以替代在客户端环境下的 Javabean 的 PropertyEidtors。 2.1.7 声明式模型验证支持 JSR303，使用 Hibernate Validator 作为默认实现：12345678public class Person &#123; @NotNull @Max(64) private String name; @Min(0) private int age; &#125; 2.2 spring 3.12.2.1 新增特性 Cache 抽象 Bean 定义配置文件 Environment 抽象 PropertySource 抽象 注解代替 xml 配置 对 Hibernate 4.x 的支持 TestContext 框架对 @Configuration 和 Bean 定义配置文件 的支持 更为简洁的构造函数注入 c: namespace 非标准 setter 类的注入 Servlet 3 code-based configuration of Servlet Container 的支持 Servlet 3 MultipartResolver 的支持 改善了 O/R 映射支持，允许无persistence.xml的JPA包扫描 可以在 controller 中，使用 annotation 临时指定特殊的 Mapping 或者 ExceptionHandler，而且整个体系更加灵活和可扩展。 2.3 spring 3.22.3.1 新增特性 支持基于Servlet 3的异步请求处理 Spring MVC Test框架 内容协商（Content Negotiation）改进。ContentNeogtiationStrategy 现在可以根据传入请求确定请求的媒体类型。可用的实现是基于文件扩展名、查询参数、“Accept”头或者一个固定的内容类型。 @ControllerAdvice 矩阵变量（Matrix Variables），增加了 @MatrixVariable 用于从请求URI中提取矩阵变量。 增加了一个抽象基础类用于支持基于代码的Servlet 3+容器初始化。 ResponseEntityExceptionHandler，用于处理异常消息的转换，和 DefaultHandlerExceptionResolver 的区别在于，这个类返回 ModelAndView。 RestTemplate 和 @RequestBody 的参数支持泛型。 支持Jackson JSON 2 支持Tiles 3 改进 @RequestBody。@RequestBody 和 @RequestPart 的参数现在可以跟随Error参数，使它可以在 @RequestMapping 方法中处理验证的错误，@RequestBody 现在有一个 required 属性。 HTTP PATCH 方法。HTTP PATCH方法现在可用于@RequestMapping 拦截器（Interceptor）支持 URL patterns 在注入点（Injection Point）和Bean方法定义中使用元注解 初步支持JCache 0.5 @DateTimeFormat不再依赖Joda Time 全局日期时间格式化 新的测试特性 并发性的微调 基于Gradle的构建系统，并迁移到GitHub 支持Java SE 7和OpenJDK 7 3. spring 4.x 的新特性3.1 spring 4.03.1.1 新增特性 删除了被丢弃的包和方法 Java 8 的支持，最低需要 Java 6 使用 Java EE 6 或以上的版本来作为基线，同时包含了相关的 JPA2.0 和 Servlet3.0 的规范 使用 Groovy 的 DSL（DomainSpecific Languages）来定义 Bean 核心容器的改进 Spring 注入 Bean 的时候把泛型类型当成一种形式的限定符。使用 Spring DataRepository 可以方便的插入特定的实现：@Autowired Repository customerRepository。 使用 Spring 的元注解支持，可以开发自定义注解来公开源注解的特定属性。 当自动装配到 lists 和 arrays 时，Beans 可以被排序，支持 @Order 注解和 Ordered 接口两种方式。 @Lazy 注解可以用在注入点以及 @Bean 定义上。 引入 @Description 注解,开发人员可以使用基于Java 方式的配置。 根据条件筛选 Beans 的广义模型通过 @Conditional 注解加入。这和@Profile支持的类似，但是允许以编程式开发用户定义的策略。 基于 CGLIB 的代理类不在需要默认的构造方法。 框架支持管理时区。 常规 Web 改进 在 Spring MVC 应用中使用新的 @RestController 注解时，不再需要给 @RequestMapping 的方法添加 @ResponseBody 注解。 AsyncRestTemplate 类已被添加进来，当开发 REST 客户端时，允许非阻塞异步支持。 当开发 Spring MVC 应用时，Spring 现在提供了全面的时区支持 WebSocket, SockJS 和 STOMP 消息 测试改进，引入了几个用于单元测试和集成测试的新功能 几乎 spring-test 模块中所有的注解（例如：@ContextConfiguration、@WebAppConfiguration、@ContextHierarchy、@ActiveProfiles 等等)可以用作元注解来创建自定义的 composed annotations 并且可以减少测试套件的配置。 现在可以以编程方式解决 Bean 定义配置文件的激活。只需要实现一个自定义的 ActiveProfilesResolver，并且通过 @ActiveProfiles的resolver 属性注册。 新的 SocketUtils 类被引入到了 spring-core 模块。 3.2 spring 4.13.2.1 新增特性 核心部分基本上无变化，提供了 DirectFieldAccessor 用于直接字段访问、yaml 配置、SpEL 的字节码编译化、BackOff 退避算法的基本实现、Base64Utils、SmartInitializingSingleton等； 在任务调度和事件机制上加入了异常处理部分； cache 部分加入 jcache 的集成、类级别的 @CacheConfig 的支持、CacheResolver； mvc 部分提供了一些视图解析器的 mvc 标签实现简化配置、提供了 GroovyWebApplicationContext 用于 Groovy web 集成、提供了 Gson、protobuf 的 HttpMessageConverter、静态资源处理方面添加了 resolver和 transformer、提供了对 groovy-templates 模板的支持、JSONP 的支持、对 Jackson 的 @JsonView 的支持等； 提供了页面自动化测试框架 Spring MVC Test HtmlUnit； test 部分提供了更便利的 @sql 标签来执行测试脚本的初始化、MockRestServiceServer 对 AyncRestTemplate 支持、MockMvcConfigurer 来全局配置 MockMvc； 提供了对 Java 8 Optional 的支持（ObjectToOptionalConverter 实现；可以在MVC中如 @RequestParam 等注解的绑定）、从Spring 4.1起 Ehcache 支持需要 EhCache 2.5 或更高版本、兼容 Quartz 2.1.4、支持 javax.annotation.Priority（等价于@Order）、JMS API的增强、SpringJUnit4ClassRunner 需要 JUnit 4.9或更高版本支持。 参考资料：开涛的博客–Spring 4.1 新特性——综述BigZ的专栏–Spring 4.0 新功能和增强中文翻译 Spring Framework 4.x参考文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F11%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github 与 Hexo 搭建博客步骤（使用 Next 主题）]]></title>
      <url>%2F2016%2F11%2F11%2FGithub%E4%B8%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[1. 安装前的准备Hexo 是一个快速简单并且强大的博客框架，使用者可以使用 markdown 语法编写文章，然后通过 hexo 生成带有主题的静态文件，并上传到 github，生成的 html 文件可以在浏览器上访问。本安装教程是在 ubuntu 平台上进行的，其他平台请另寻他处。安装前 Hexo 前需要先安装 Node.js 和 Git，在后面会描述其安装过程。 2. 安装 Git使用如下命令安装 Git，在这之后可以先了解 git 简单命令的使用，推荐：廖雪峰的Git教程。 1$ sudo apt-get install git-core 3. 安装 Node.js我们可以使用 nvm 来安装 Node.js ，方法如下：1curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh 或1$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh 安装完 nvm 之后重启窗口安装 Node.js：1$ nvm install stable 如果不想使用命令安装可以直接下载 Node.js 的安装包安装。下载完 linux 下的压缩包后，将其复制到 /usr/local 目录下，并使用 tar -xvJf + 文件名，对压缩包进行解压，更改解压后的文件夹的权限为755。修改环境变量，使用 vim 修改 /etc/profile，在文件末尾添加两行：123# node.jsexport NODE=/usr/local/node-v6.9.1-linux-x64export PATH=$&#123;NODE&#125;/bin:$PATH 之后执行命令 source /etc/profile，使用 node -v 命令查看版本号。 4. 安装 Hexo使用 npm 安装 hexo：1234$ sudo apt-get install npm$ sudo apt-get update$ sudo apt-get install nodejs-legacy$ sudo npm install -g hexo-cli 经过一段时间的等待，会在终端显示如下树状结果，hexo 安装完毕。 当 hexo 安装完毕，使用如下命令初始化 hexo 目录并安装依赖，生成的目录在当前所在的目录之下。123$ hexo init &lt;folder&gt; # 初始化 hexo 并创建目录$ cd &lt;folder&gt; # 切换到目录之下$ npm install # 安装依赖包 hexo 常用命令：1234$ hexo g #完整命令为hexo generate，用于生成静态文件$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上$ hexo n #完整命令为hexo new，用于新建一篇文章 在本地开启博客，用浏览器访问 http://localhost:4000/：12$ hexo g$ hexo s 5. 注册 Github 并创建 repository到 Github 官网注册 Github 账号，登录进入个人主页选择 Repositories，再点击旁边的 NEW 按钮创建新的 repository，名字的格式必须为 name.github.io，例如：windows7lake.github.io。 6. hexo 的配置整个博客的配置文件，位于 hexo\_config.yml，通过它，我们可以对整个博客进行配置。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Lio's Blog # 网站即博客的标题subtitle: No pains no gains! # 博客的副标题description: No pains no gains, Believes oneself, Nothing impossible! # 博客的描述author: Lio Lin # 作者language: zh-CN # 语言timezone:# URL 设置自己的域名## If your site is put in a subdirectory,## set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # 新创建的文章的默认文件名default_layout: post titlecase: false # 将标题转换为标题大小写external_link: true # 在新的标签中打开外部连接filename_case: 0 # 0 为默认; 1 为小写; 2 为大写render_drafts: false # 是否显示草稿post_asset_folder: falserelative_link: false # 是否创建相对于根文件夹的链接future: truehighlight: # 代码块设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示的文章数，0 表示不分页pagination_dir: page # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 主题名# Deployment 部署到 github 的配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/windows7lake/windows7lake.github.io branch: master 使用如下命令克隆 Next 主题到我们的本地博客之下：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 主题的配置文件，位于 hexo\theme\主题名\_config.yml，对主题的设置。这里对主题的配置可以参考 NexT 官网。 7. 将本地 Hexo 发布到 Github在本地创建 ssh key：1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的 your_email@youremail.com 改为自己的邮箱，之后会要求确认路径和输入密码，一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。 回到 github，进入 Settings，选择 SSH and GPG Keys -&gt; New SSH Key，title 随便填，粘贴 key。为了验证是否成功，输入：1$ ssh -T git@github.com 如果是第一次的会提示是否 continue，输入 yes 就会看到：You’ve successfully authenticated， but GitHub does not provide shell access ，这就表示已成功连上 github。 接下来我们要做的就是把本地仓库传到 github 上去，在此之前还需要设置 username 和 email，因为 github 每次 commit 都会记录他们。12$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 发布本地博客内容到 Github，需切换到博客目录下，执行如下两条命令，执行如下的第二个命令，可能会要你输入用户名和密码，皆为注册 Github 时的数据，输入密码是不显示任何东西的，输入完毕回车即可。12$ hexo g$ hexo d 如果输入 hexo d 后遇到 ERROR Deployer not found: Git，则使用命令 npm install hexo-deployer-git –save 即可。]]></content>
    </entry>

    
  
  
</search>
