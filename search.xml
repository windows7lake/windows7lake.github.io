<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Spring笔记（十一）—— 事务管理之 ThreaLocal]]></title>
      <url>%2F2016%2F11%2F22%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B9%8B%20ThreaLocal%2F</url>
      <content type="text"><![CDATA[按照传统的经验，如果某个对象是非线程安全的，在多线程环境下，对对象的访问必须采用 synchronized 进行线程同步，但线程同步机制会降低并发性，影响系统性能。ThreaLocal 可以改变这种方式。 认识JDK 1.2 版本开始提供 java.lang.ThreaLocal，ThreaLocal 为解决多线程程序的并发问题提供了新的思路。ThreaLocal 是线程的一个本地化对象，当工作于多线程中的对象使用 ThreadLocal 维护变量时，它会为每个使用该变量的线程分配一个独立的变量副本。所有每个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本；从线程的角度看，这个变量就像是线程的本地变量。 接口方法ThreadLocal 支持泛型，且有四个简单的接口： void set(T value)：设置当前线程的线程局部变量的值。 public T get()：该方法返回当前线程所对应的线程局部变量。 public void remove()：将当前线程局部变量的值删除，目的是为了减少内存的占用（JDK 5.0 新增）。当线程结束后，对应该线程的局部变量将会自动被垃圾回收，所以显示调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 protected T initialValue()：返回该线程局部变量的初始值，该方法是一个 protected 方法，为了让子类覆盖而设计。 ThreadLocal 的实现思路：在 ThreadLocal 内部有一个 Map，用于存储每一个线程的变量副本，Map 中的元素的 key 为线程对象，value 为对应线程的变量副本。 实例1234567891011121314151617181920212223242526272829303132public class SequenceNumber &#123; private static class TestClient extends Thread &#123; private SequenceNumber sn; public TestClient(SequenceNumber sn) &#123; this.sn = sn; &#125; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println("Thread[" + Thread.currentThread().getName() + "] sn[" + sn.getNextNum() + "]") &#125; &#125; &#125; private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() &#123; public Integer initialValue() &#123; return 0; &#125; &#125;; public int getNextNum() &#123; seqNum.set(seqNum.get() + 1); return seqNum.get(); &#125; public static void main(String[] args) &#123; SequenceNumber sn = new SequenceNumber(); TestClient t1 = new TestClient(sn); TestClient t2 = new TestClient(sn); TestClient t3 = new TestClient(sn); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果：123456789Thread[Thread-2] sn[1]Thread[Thread-0] sn[1]Thread[Thread-1] sn[1]Thread[Thread-2] sn[2]Thread[Thread-0] sn[2]Thread[Thread-1] sn[2]Thread[Thread-2] sn[3]Thread[Thread-0] sn[3]Thread[Thread-1] sn[3] 从输出结果上看，由于 ThreadLocal 为每一个线程提供了单独的副本，所以每个线程所产生的序号虽然都共享同一个 SequenceNumber 实例，但它们没有发生相互干扰的情况，而是各自产生独立的序列号。 与线程同步机制的比较在线程同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序解决什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等复杂的问题。ThreadLocal 从另一个角度解决多线程的并发访问，为每个线程提供独立的变量副本，从而隔离了多个线程对访问数据的冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对变量进行同步。ThreadLocal 提供了线程安全的对象封装，在编写多线程代码时，可以把部安全的变量封装进 ThreadLocal。总的来说，同步机制采用“以时间换空间”的方式：访问串行化，对象共享化；而 ThreadLocal 采用“以空间换时间”的方式：访问并行化，对象独享化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（十）—— 事务管理之数据库事务基础知识]]></title>
      <url>%2F2016%2F11%2F22%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[概念数据库事务(Database Transaction)，是指作为单个逻辑工作单元执行的一系列操作（可理解为对数据库的简单操作，如：增删查改），要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作（将一组相关操作组合为一个单元）都成功完成，否则不会将数据库操作真正地写入数据库，如此简化错误恢复的实现，并使应用程序更加可靠。数据库事务必须满足 4 大特性（简称 ACID）： 原子性（Atomic）：表示包含多个数据库操作的事务只有所有操作都成功，整个事务才提交；若其中一个操作失败，则撤销所有操作，让数据库返回初始状态。 一致性（Consistency）：事务操作成功后，数据库整体状态与业务规则一致。如 A 转账 100 给 B，不论操作是否成功，A 和 B 的存款总额不变。 隔离性（Isolation）：并发操作中，不同事务拥有各自的数据空间，且彼此的操作不会相互干扰。 持久性（Durability）：一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证能够通过某种机制恢复数据。 数据并发多个客户端连接同一个数据库进行并发访问时，数据库中的同一个数据可能会被多个事务访问，这时需要采用适当的隔离措施，保护数据的完整性。 脏读A 事务读取 B 事务尚未提交的更改数据，并在此基础上进行操作。当 B 进行事务回滚时，则 A 事务读取的数据不会被承认。下图中黑点代表开始事务，白点表示提交事务。脏读 不可重复读不可重复读指 A 事务读取数据后，B 事务执行更新操作，使 A 事务无法再现前一次读取结果。不可重复读 幻读A 事务读取 B 事务提交的新增数据。幻读和不可重复读不一样，前者是指读到了其他已经提交事务的新增数据，后者指读到了已经提交事务的更改数据；防止读取到更改数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生变化，而防止读取到新增数据，往往需要添加表级锁（将整个表锁定，防止新增数据）。幻读 第一类丢失修改A 事务撤销时，把已经提交的 B 事务的更新数据覆盖了。第一类丢失修改 第二类丢失修改A 事务覆盖 B 事务已经提交的数据，造成 B 事务所做操作丢失。第二类丢失修改 数据库锁机制按锁定的对象的不同，一般可以分为表锁定和行锁定，前者对整个表进行锁定，而后者对表中特定行进行锁定。从并发事务锁定的关系上看，可以分为共享锁定和独占锁定。共享锁定会防止独占锁定，但允许其他的共享锁定；而独占锁定既防止其他的独占锁定，也防止其他的共享锁定。 事务隔离数据库为用户提供了锁的 DML 操作方式，但直接使用锁管理比较麻烦，因此数据库为用户提供可自动锁机制。只要用户指定回话的事务隔离级别，数据库就会分析事务中的 SQL 语句，然后自动为事务操作的数据资源添加适当的锁。ANISI/ISO SQL 92 标准定义了 4 个等级的事务隔离级别，在相同的数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。 隔离级别 脏读 不可重复读 幻读 第一类丢失修改 第二类丢失修改 READ UNCOMMITTED 允许 允许 允许 不允许 允许 READ COMMITTED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（九）—— AOP 之资源访问接口 Resource]]></title>
      <url>%2F2016%2F11%2F21%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%20AOP%20%E4%B9%8B%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%20Resource%2F</url>
      <content type="text"><![CDATA[JDK 提供的访问资源的类（java.net.URL 和 File）不能满足各种底层资源的访问需求，比如缺少从类路径或 Web 容器的上下文中获取资源的操作类。因此，Spring 设计了一个 Resource 接口，为应用提供了更强的访问底层资源的能力。 资源接口 Resource123456789public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isOpen(); URL getURL() throws IOException; File getFile() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; 123public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125; Resource 接口的主要方法： getInputStream()：返回资源对应的输入流。 exists()：资源是否存在。 isOpen()：资源是否打开。 getDescription()：返回对资源的描述。 getURL()：如果底层资源可以表示成URL，则返回对应的 URL 对象。 getFile()：如果底层资源对应一个文件，则返回对应的 File 对象。 Resource 的具体实现类 UrlResource：Url 封装了 java.net.URL，它使用户能够访问任何可以通过 URL 表示的资源，如文件系统的资源、HTTP 资源、FTP 资源等。 ClassPathResource：类路径下的资源，资源以相对于类路径的方式表示。 FileSystemResource：文件系统资源，资源以文件系统路径的方式表示。 ServletContextResource：为访问 Web 容器上下文中的资源而设计的类，负责以相对于 Web 应用根目录的路径加载资源，它支持以流和 URL 的方式访问，在 WAR 解包的情况下，也可以通过 File 的方式访问，该类还可以直接从 JAR 包中访问资源。 InputStreamResource：以输入流返回表示的资源。 ByteArrayResource：二进制数组表示的资源，二进制数组资源可以在内存中通过程序构造。 示例：1234567891011121314151617181920import java.io.IOException;import java.io.InputStream;import org.springframework.core.io.ClassPathResource;import org.springframework.core.io.FileSystemResource;import org.springframework.core.io.Resource;public class ResourceTest &#123; public static void main(String[] args) &#123; try &#123; String filePath = "D:/config/file.txt"; // 使用系统文件路径方式加载文件 Resource res1 = new FileSystemResource(filePath); // 使用类路径方式加载文件 Resource res1 = new ClassPathResource("conf/file.txt"); InputStream ins1 = res1.getInputStream(); InputStream ins2 = res2.getInputStream(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 资源地址表达式Spring 提供了强大的加载资源的机制，不但能够通过 classpath:、file: 等资源地址前缀识别不同的资源类型，还支持 Ant 风格带通配符的资源地址。 地址前缀 示例 对应资源类型 classpath: classpath:com/myapp/config.xml 从类路径中加载资源，资源文件可以在标准的文件系统中，也可以在 jar 或 zip 的类包中 file: file://data/config.xml 使用 UrlResource 从文件系统目录中装载资源，可采用绝对或相对路径 http:// http://myserver/logo.png 使用 UrlResource 从 Web 服务器中装载资源 ftp:// ftp://myserver/my.txt 使用 UrlResource 从 FTP 服务器中装载资源 没有前缀 /data/config.xml 根据 ApplicationContext 具体实现类采用对应的类型的 Resource Ant 风格资源地址支持 3 种匹配符： ?：匹配文件名中的一个字符 *：匹配文件名中任意个字符 **：匹配多层路径 示例： classpath:com/t?st.xml：匹配 com 类路径下 com/test.xml，com/tast.xml 或者 com/tdst.xml file:D:/conf/*.xml：匹配文件系统 D:/conf 目录下所有以 xml 为后缀的文件 classpath:com/**/test.xml：匹配 com 类路径下（当前目录及其子孙目录）的 test.xml 文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（八）—— AOP 之基于 Schema 配置]]></title>
      <url>%2F2016%2F11%2F20%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%20AOP%20%E4%B9%8B%E5%9F%BA%E4%BA%8E%20Schema%20%E7%9A%84%20AOP%20%E6%94%AF%E6%8C%81%2F</url>
      <content type="text"><![CDATA[Spring 提供了使用新的 aop 命名标签定义切面的支持，使得我们可以使用 Schema 配置切面。基于 @AspectJ 注解的切面，本质上是将切点、增强类型的信息使用注解进行描述；而在基于 Schema 的实现方式中，把这两个信息移到 Schema 的 XML 配置文件中。虽然配置方式不同，但两者表达的信息完全相同。使用基于 Schema 的切面定义后，切点、增强类型的注解信息从切面类中剥离出来，原本的切面类变成了真正意义上的 POJO。在 Spring 配置中，所有的 aspect、pointcut 和 advisor 元素都需要放置在 &lt;aop:config&gt; 元素之下。 声明切面（aspect）使用 Schema 支持时，一个切面只是一个 POJO 类，它在 Spring 应用程序上下文中定义为一个 Bean。状态和行为由对象的字段和方法提供，切点和增强由 XML 配置文件提供。切面的声明使用 &lt;aop:aspect&gt; 元素，而 bean 使用 ref 属性注入。12345678&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aBean" class="..."&gt; ...&lt;/bean&gt; 声明切点（pointcut）使用切点表达式的方式：1234&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;&lt;/aop:config&gt; 直接声明切点的方式：1234&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;&lt;/aop:config&gt; 声明增强（advice）和 @AspecJ 所支持的类型一致，sechema 也支持 5 种增强方式，且在使用方法上也大致相同。参考 Spring笔记（七）—— AOP 之 @AspectJ 支持 Before advice在 &lt;aop:aspect&gt; 元素下使用 &lt;aop:before&gt; 子元素声明。12345&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; 上面的 dataAccessOperation 是切点的 id，要直接定义切点，需要使用 pointcut 属性代替 pointcut-ref：12345&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut="execution(* com.xyz.myapp.dao.*.*(..))" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; After returning advice使用 returning 属性指定传递返回值的参数名：1234567&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" returning="retVal" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; doAccessCheck 方法必须声明一个名为 retVal 的参数，此参数的类型以与 @AfterReturning 中所述相同的方式约束匹配。1public void doAccessCheck(Object retVal) &#123;...&#125; After throwing advice使用 throwing 属性指定应传递异常的参数的名称：1234567&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" throwing="dataAccessEx" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt; doRecoveryActions 方法必须声明一个名为 dataAccessEx 的参数：1public void doRecoveryActions(DataAccessException dataAccessEx) &#123;...&#125; After (finally) advice123456&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt; &lt;aop:after pointcut-ref="dataAccessOperation" method="doReleaseLock"/&gt; ...&lt;/aop:aspect&gt; Around adviceAround advice 通常于线程安全的方式下，在要执行的方法前后分享状态时使用。123456&lt;aop:aspect id="aroundExample" ref="aBean"&gt; &lt;aop:around pointcut-ref="businessService" method="doBasicProfiling"/&gt; ...&lt;/aop:aspect&gt; 123456public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal;&#125; Introductions通过 &lt;aop:declare-parents&gt; 配置引介增强，引介增强和其它类型的增强不同，它没有 method、pointcut 和 pointcut-ref 属性：123456789&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt; &lt;aop:declare-parents types-matching="com.xzy.myapp.service.*+" implement-interface="com.xyz.myapp.service.tracking.UsageTracked" default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt; &lt;aop:before pointcut="com.xyz.myapp.SystemArchitecture.businessService() and this(usageTracked)" method="recordUsage"/&gt;&lt;/aop:aspect&gt; &lt;aop:declare-parents&gt; 通过 implement-interface 属性声明要实现的接口，通过 default-impl 属性指定默认的接口实现类，通过 types-matching 属性以 AspectJ 切点表达式语法指定哪些 Bean 需要引介 UsageTracked 接口的实现。注意：虽然 &lt;aop:declare-parents&gt; 没有 method 属性指定增强方法所在的 Bean，但 &lt;aop:aspect id=&quot;usageTrackerAspect&quot; ref=&quot;usageTracking&quot;&gt; 的 ref 属性依然要指定一个增强 Bean。 AdvisorsAdvisors 是 Spring 中切面概念的对应物，是切点和增强的复合体，不过仅包含一个切点和一个增强。在 AspectJ 中没有对应的等价物，在 aop Schema 配置样式中，可以通过 &lt;aop:advisor&gt; 配置一个 Advisor。通过 advice-ref 属性引用基于接口定义的增强，通过 pointcut 定义切点表达式，或通过 pointcut-ref 引用一个命名的切点。123456789101112&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; &lt;aop:advisor pointcut-ref="businessService" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（七）—— AOP 之 @AspectJ 支持]]></title>
      <url>%2F2016%2F11%2F19%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%20AOP%20%E4%B9%8B%20%40AspectJ%20%E6%94%AF%E6%8C%81%2F</url>
      <content type="text"><![CDATA[开启 @AspectJ 支持@AspectJ 指的是使用注解标注的常规 Java 类的样式声明切面，@AspectJ 样式是 AspectJ 项目引入的，作为 AspectJ 5 版本的一部分。Spring 使用由 AspectJ 提供的库 aspectjweaver.jar（要求版本至少为 1.6.8），就能像 AspectJ 5 那样解析注解。 Java 配置方式1234@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125; XML 配置方式1&lt;aop:aspectj-autoproxy/&gt; 声明切面（aspect）当开启 @AspectJ 支持时，任何在应用程序上下文中使用类（包含 @AspectJ 注解）定义的 bean 都会被 Spring 侦测到，并用于配置 Spring AOP。如下为应用程序上下文中的常规 bean 定义，指向具有 @AspectJ 注解的 bean 类：123&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt; &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt; 还有具有 @AspectJ 注解的 NotVeryUsefulAspect 类：12345package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125; 声明切点（pointcut）切点能够定位特定的连接点，从而使我们能够控制何时执行增强操作。切点声明有两部分：一个包含方法名和任意参数的签名，以及一个切入点表达式（它标明要执行的方法的位置）。在 AOP 的 @AspectJ 注解风格中，切点签名由一个常规方法定义，切点表达式使用 @Pointcut 注解表示（用作切点签名的方法必须具有 void 返回类型）。12@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature 切点表达式函数Aspectj5 的切点表达式由关键字和操作参数组成，如 execution(* transfer(..))，execution 为关键字，* transfer(..) 为操作参数。在上面的例子中，execution 代表目标类执行某一方法，* transfer(..) 描述目标方法的匹配模式串，两个联合起来表示目标类 transfer() 方法的连接点。 Spring 支持 9 个 @AspectJ 切点表达式函数，它们用不同的方式描述目标类的连接点，根据描述对象的不同，大致分为 4 个类型： 方法切点函数：通过描述目标类方法信息定义连接点。 execution(方法匹配模式串)：表示满足某一匹配模式的所有目标方法连接点。如 execution(* transfer(..)) 表示所有目标类中的 transfer() 方法；execution(public * *(..)) 表示所有目标类中的 public 方法。 @annotation(方法注解类名)：表示标注了特定注解的目标方法连接点。如 @annotation(com.lake.NeedTest) 表示任何标注了 @NeedTest 注解的目标类方法。 方法入参切点函数：通过描述目标类方法入参的信息定义连接点。 args(类名)：通过判别目标类方法运行时入参对象的类型定义指定连接点。如 args(com.lake.Waiter) 表示所有有且仅有一个按类型匹配于 Waiter 入参的方法。 @args(类型注解类名)：通过判别目标方法运行时入参对象的类是否标注特定注解来指定连接点。如 @args(com.lake.Monitorable) 表示任何这样的一个目标方法：它有一个入参且入参对象的类标注 @Monitorable 注解。 目标类切点函数：通过描述目标类类型信息定义连接点。 within(类名匹配串)：表示特定域下的所有连接点。如 within(com.lake.service.*) 表示 com.lake.service 包中的所有连接点，即包中所有类的所有方法，而 within(com.lake.service.*Service) 表示在 com.lake.service 包中所有以 Service 结尾的类的所有连接点。 target(类名)：假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过 target(com.lake.Waiter) 定义的切点、Waiter 以及 Waiter 实现类 NativeWaiter 中所有连接点都匹配该切点。 @within(类型注解类名)：假如目标类按类型匹配于某个类 A，且类 A 标注了特定注解，则目标类的所有连接点匹配这个切点。如 @within(com.lake.Monitorable) 定义的切点，假如 Waiter 类标注了 @Monitorable 注解，则 Waiter 以及Waiter 实现类 NativeWaiter 中所有连接点都匹配。 @target(类型注解类名)：目标类标注了特定注解，则目标类所有连接点匹配这个切点。如 @target(com.lake.Monitorable) 定义的切点，假如 NativeWaiter 类标注了 @Monitorable 注解，则 NativeWaiter 所有连接点都匹配切点。 代理类切点函数：通过描述目标类的代理类的信息定义连接点。 this(类名)：代理类按类型匹配于指定类，则被代理的目标类所有连接点匹配切点。 函数入参通配符@AspectJ 支持 3 种通配符： * ：匹配任意字符，但它只能匹配上下文中的一个元素 .. ：匹配任意字符，可以匹配上下文中的多个元素，但在表示类时，必须和 * 联合使用，而在表示入参时则单独使用 + ：表示按类型匹配指定类的所有类，必须跟在类名后面，如 com.lake.Car+。继承或扩展指定类的所有类，同时还包括指定类本身 @AspectJ 函数按其是否支持通配符及支持的程度，分为 3 类： 支持所有通配符：execution(), within() 仅支持 + 通配符：args(), this(), target() 不支持通配符：@args(), @within(), @target(), @annotation() 逻辑运算符切点表达式由切点函数组成，切点函数之间还可以进行逻辑运算，组成复合切点，Spring 支持以下切点运算符： &amp;&amp; ：与操作符，等效符号 and。如 within(com.lake.*) and args(String) 表示在 com.lake 包下所有类拥有一个 String 入参的方法 || ：或操作符，等效符号 or。如 within(com.lake..*) and args(String) 表示在 com.lake 包下所有类（当前包以及子孙包）的方法，或所有拥有一个 String 入参的方法 ! ：非操作符，等效符号 not。如 !within(com.lake.*) 表示所有不在 com.lake 包下的方法 声明增强（advice）Spring 使用增强定义横切逻辑，同时由于 Spring 只支持方法连接点，增强还包括了在方法的哪一点加入横切代码的方位信息，所以增强既包括横切逻辑，还包括部分连接点。增强与切点表达式相关联，并在切点匹配的方法执行之前，之后或周围运行。切点表达式可以是对指定切点的简单引用，也可以是在适当位置声明的切入点表达式。所有增强类型除了引介增强，其余都属于方法级别的。 @Before前置增强表示在目标方法执行前实施增强（即先执行增强方法中的代码）。使用 @Before 声明前置增强，其拥有两个属性： vlaue：该成员用于定义切点。 argNames：由于无法通过 Java 反射机制获取方法入参名，所有如果在 Java 编译时未启动调试信息或者需要在运行期解析切点，就必须通过这个成员指定注解多标注增强方法的参数名（注意两者名字必须完全相同），多个参数名用逗号分隔。 12345678910111213import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class BeforeExample &#123; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @Before("execution(* com.xyz.myapp.dao.*.*(..))") public void doAccessCheck2() &#123; // ... &#125;&#125; 如上所示，doAccessCheck() 方法会在 SystemArchitecture 类的 dataAccessOperation() 方法执行之前先执行；doAccessCheck2() 会在表达式所匹配的方法执行之前执行。 @AfterReturning后置增强表示在目标方法执行后实施增强（即后执行增强方法中的代码）。使用 @AfterReturning 声明后置增强，其拥有四个属性： vlaue：该成员用于定义切点。 pointcut：表示切点的信息，如果显示指定 pointcut 值，它将覆盖 value 的设置值，可以将 pointcut 属性看成 value。 returning：将目标对象方法的返回值绑定给增强的方法。 argNames：如上所述 123456789101112131415import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterReturning;@Aspectpublic class AfterReturningExample &#123; @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @AfterReturning( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal") public void doAccessCheck2(Object retVal) &#123; // ... &#125;&#125; @Around环绕增强表示在目标方法执行前后实施增强（即前后都执行增强方法中的代码）。使用 @Around 声明环绕增强，其拥有两个属性： vlaue：该成员用于定义切点。 argNames：如上所述 12345678910111213import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.ProceedingJoinPoint;@Aspectpublic class AroundExample &#123; @Around("com.xyz.myapp.SystemArchitecture.businessService()") public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; &#125;&#125; @AfterThrowing异常抛出增强表示在目标方法抛出异常后实施增强。使用 @AfterThrowing 声明抛出增强，其拥有四个属性： vlaue：该成员用于定义切点。 pointcut：表示切点的信息，如果显示指定 pointcut 值，它将覆盖 value 的设置值，可以将 pointcut 属性看成 value。 returning：将抛出的异常绑定给增强的方法。 argNames：如上所述 123456789101112131415import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.AfterThrowing;@Aspectpublic class AfterThrowingExample &#123; @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doRecoveryActions() &#123; // ... &#125; @AfterThrowing( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing="ex") public void doRecoveryActions(DataAccessException ex) &#123; // ... &#125;&#125; @AfterFinal 增强，不管是抛出异常或者是正常退出，该增强都会得到执行，一般用于释放资源，相当于 finally。使用 @After 声明 Final 增强，其拥有两个属性： vlaue：该成员用于定义切点。 argNames：如上所述 123456789import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.After;@Aspectpublic class AfterFinallyExample &#123; @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doReleaseLock() &#123; // ... &#125;&#125; @DeclareParents引介增强是一种比较特殊的增强类型，它不是在目标方法周围织入增强，而是为目标类创建新的方法和属性，所以引介增强的连接点是类级别的，而非方法级别的。通过引介增强可以为目标类添加一个接口的实现，即原来目标类未实现某个接口，通过引介增强可以为目标类创建实现某接口的代理。使用 @DeclareParents 声明引介增强，其拥有两个属性： vlaue：该成员用于定义切点，它表示在哪个目标类上添加引介增强。 defaultImpl：默认的接口实现类。 示例：给定一个接口 UsageTracked 以及该接口的实现 DefaultUsageTracked，vlaue 属性指向需要添加接口实现的类，defaultImpl 属性指向默认的接口实现类。通过 @DeclareParents 为 value 属性的 AspectJ 切点表达式语法所匹配的类添加一个需要实现的 UsageTracked 接口，并指定其默认实现类为 DefaultUsageTracked，然后通过切面技术将 DefaultUsageTracked 融合到 value 属性的 AspectJ 切点表达式语法所匹配的类，这样 value 属性的 AspectJ 切点表达式语法所匹配的类就实现了 UsageTracked 接口了。123456789@Aspectpublic class UsageTracking &#123; @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount(); &#125;&#125; 1interface UsageTracked &#123;&#125; 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（六）—— IOC 容器之不同的配置方式]]></title>
      <url>%2F2016%2F11%2F18%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%E4%B8%8D%E5%90%8C%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[基于注解的配置XML 设置的替代方法是基于注释的配置，它依赖于字节码元数据来连接组件而不是角括号声明。开发人员通过使用相关类，方法或字段声明上的注释来将配置移动到组件类本身中，而不是使用 XML 来描述 bean 布线。例如，Spring2.0 引入了使用 @Required 注释实现 required 属性的可能性。Spring2.5 添加了对 JSR-250 注释的支持，例如 @PostConstruct 和 @PreDestroy。Spring3.0 增加了对 javax.inject 包中包含的 JSR-330（Java的依赖注入）注释的支持，例如 @Inject 和 @Named。 @required@Required 注释适用于 bean 属性的 setter 方法，此注释表示被标注的 bean 属性必须在配置时通过 bean 定义中的显式属性值或通过自动装配被填充，如果被标注的 bean 属性未被填充，容器将抛出异常。如下例子所示：12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Required public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; @AutowiredSpring 通过 @Autowired 注解实现 Bean 的依赖注入，可以运用在多种自动注入场景。 应用于构造函数Spring 框架4.3，如果目标 bean 只定义了一个构造函数，则可以不需要 @Autowired。如果有多个构造函数，则至少必须为其中一个声明注解，告知容器哪一个是必须被使用的。12345678public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; 应用于 setter 方法12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; 应用于拥有参数的某个方法12345678910public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; 应用于字段或与构造函数混合使用12345678910public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired private MovieCatalog movieCatalog; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; 应用于数组或集合123456789101112131415public class MovieRecommender &#123; @Autowired private MovieCatalog[] movieCatalogs; private Set&lt;MovieCatalog&gt; movieCatalogs; @Autowired public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs; &#125; private Map&lt;String, MovieCatalog&gt; movieCatalogs; @Autowired public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs; &#125; // ...&#125; 应用于泛型原始类：1234567891011@Configurationpublic class MyConfiguration &#123; @Bean public StringStore stringStore() &#123; return new StringStore(); &#125; @Bean public IntegerStore integerStore() &#123; return new IntegerStore(); &#125;&#125; 泛型类：1234567891011@Configurationpublic class MyConfiguration &#123; @Autowired private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean @Autowired private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean // Inject all Store beans as long as they have an &lt;Integer&gt; generic // Store&lt;String&gt; beans will not appear in this list @Autowired private List&lt;Store&lt;Integer&gt;&gt; s;&#125; required 属性如果容器中没有一个和标注变量类型匹配的 Bean，Spring 容器启动时会抛出异常，默认情况下，required 属性值为 true，即要求一定要找到匹配的 Bean。12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired(required=false) public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; @Primary因为按类型自动装配可能导致多个候选项，所以通常需要对选择过程有更多的控制。@Primary 表示当多个 bean 自动装配到单值依赖关系的候选项时，应该优先选择 @Primary 指定的 bean。如果候选项中只有一个 primary bean，那么它将作为自动装配的值。如下定义 firstMovieCatalog 作为 primary MovieCatalog：123456789@Configurationpublic class MovieConfiguration &#123; @Bean @Primary public MovieCatalog firstMovieCatalog() &#123; ... &#125; @Bean public MovieCatalog secondMovieCatalog() &#123; ... &#125; // ...&#125; @Qualifier@Qualifier 可以将限定符值与特定参数相关联，缩小类型匹配集，以便为每个参数选择特定的 bean。如果容器中有一个以上匹配的 Bean 时，则可以通过 @Qualifier 注解限定 Bean 的名称。123456public class MovieRecommender &#123; @Autowired @Qualifier("main") private MovieCatalog movieCatalog; // ...&#125; @Qualifier 也可以用于独立的构造函数参数或方法参数：1234567891011public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(@Qualifier("main")MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; @Resource@Resource 要求提供一个 Bean 名称的属性，如果没有明确指定名称，则默认名称派生自字段名称或 setter 方法。在字段的情况下，它采用字段名称; 在 setter 方法的情况下，它接受 bean 属性名称。1234567public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource(name="myMovieFinder") public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 以下示例使用名称为 movieFinder 的 bean 注入到其 setter 方法中：1234567public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; @Autowired 默认按类型匹配注入 Bean，@Resource 则按名称匹配注入 Bean，@Inject 和 @Autowired 一样按类型匹配注入 Bean，只不过它没有 required 属性。 @PostConstruct 和 @PreDestroy使用 &lt;bean&gt; 进行配置时，可以通过 init-method 和 destory-method 属性指定 Bean 的初始化及容器销毁前执行的方法。Spring 从 2.5 开始支持 JSR-250 中定义的 @PostConstruct 和 @PreDestroy 注解，在 Spring 中相当于 init-method 和 destory-method 属性的功能，不过使用注解时，可以在一个 Bean 中定义多个 @PostConstruct 和 @PreDestroy 方法。12345678910public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; 基于 Java 类的配置@Bean 注解用于表示方法实例化，配置和初始化一个由 Spring IoC 容器管理的新对象。@Bean 注释与 &lt;bean/&gt; 元素具有相同的作用。@Configuration 注解表示被标注的 POJO 类可以为 Spring 容器提供 Bean 定义的信息。简单的实例如下：1234567@Configurationpublic class AppConfig &#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 与 AppConfig 类等同的 XML 配置：123&lt;beans&gt; &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;&lt;/beans&gt; @Bean@Bean 是一个方法级别的注解和 XML &lt;bean/&gt; 元素的替代，它支持 init-method, destroy-method, autowiring 和 name 等 &lt;bean/&gt; 提供的属性。1234567891011121314151617181920212223public class Foo &#123; public void init() &#123; // initialization logic &#125;&#125;public class Bar &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = "init") public Foo foo() &#123; return new Foo(); &#125; @Bean(destroyMethod = "cleanup") public Bar bar() &#123; return new Bar(); &#125;&#125; @Scope用于指定 Bean 的作用域。12345678@Configurationpublic class MyConfiguration &#123; @Bean @Scope("prototype") public Encryptor encryptor() &#123; // ... &#125;&#125; 自定义 Bean 的名称，别名和描述Bean 可以通过 name 属性自定义名称，当有多个名称时，其它的为别名；还可以使用 @Description 定义 Bean 的描述信息。123456789@Configurationpublic class AppConfig &#123; @Bean(name = &#123; "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" &#125;) @Description("Provides a basic example of a bean") public DataSource dataSource() &#123; // instantiate, configure and return DataSource bean... return new DataSource(); &#125;&#125; @Configuration@Configuration 是一个类级别的注解，表示该类是为 Spring 容器提供 bean 定义信息的类。 @Import等同于 XML 配置中的 &lt;import/&gt; 元素，@Import 注解允许从另一个 Configuration 类中加载 @Bean 定义。12345678910111213141516@Configurationpublic class ConfigA &#123; @Bean public A a() &#123; return new A(); &#125;&#125;@Configuration@Import(ConfigA.class)public class ConfigB &#123; @Bean public B b() &#123; return new B(); &#125;&#125; 如上所述，ConfigB 中导入了 ConfigA，所以在实例化上下文的时候，只需要提供 ConfigB。123456public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); // now both beans A and B will be available... A a = ctx.getBean(A.class); B b = ctx.getBean(B.class);&#125; @ImportResource用于加载资源文件路径的注解。 properties-config.xml 123&lt;beans&gt; &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;&lt;/beans&gt; jdbc.properties 123jdbc.url=jdbc:hsqldb:hsql://localhost/xdbjdbc.username=sajdbc.password= bean 类 1234567891011121314@Configuration@ImportResource("classpath:/com/acme/properties-config.xml")public class AppConfig &#123; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; @Bean public DataSource dataSource() &#123; return new DriverManagerDataSource(url, username, password); &#125;&#125; main 类 12345public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); TransferService transferService = ctx.getBean(TransferService.class); // ...&#125; 不同配置方式的比较 描述 基于 XML 配置 基于注解配置 基于 Java 类配置 Bean 定义 在 XML 文件中通过 &lt;bean&gt; 元素定义 Bean。如：&lt;bean class=&quot;com.lake.UserDao&quot;/&gt; 在 Bean 实现类出通过标注 @Component 或衍型类（@Repository、@Service 及 @Controller）定义 Bean 在标注了 @Configuration 的 Java 类中，通过在类方法上标注 @Bean 定义一个 Bean，方法必须提供 Bean 的实例化逻辑 Bean 名称 通过 &lt;bean&gt; 的 id 或 name 属性定义 Bean。如：&lt;bean id=&quot;userDao&quot; class=&quot;com.lake.UserDao&quot;/&gt;，默认名称为：com.lake.UserDao#0 通过注解的 value 属性定义，如 @Component(“userDao”)，默认名称为小写字母开头的类名（不带包名）：userDao 通过 @Bean 的 name 属性定义，如 @Bean(“userDao”)，默认名称为方法名 Bean 注入 通过 &lt;property&gt; 子元素或通过 p 命名空间的动态属性，如 p:userDao-ref=”userDao” 进行注入 通过在成员变更或方法入参处标注 @Autowired，按类型匹配自动注入，还可以配合使用 @Qualifier 按名称匹配方式注入 比较灵活，可以通过在方法处通过 @Autowired 使方法入参绑定 Bean，然后在方法中通过代码进行注入，还可通过调用配置类的 @Bean 方法进行注入 Bean 作用域 通过 &lt;bean&gt; 的 scpoe 属性指定，如：&lt;bean class=&quot;com.lake.UserDao&quot; scope=&quot;prototype&quot;/&gt; 通过在类定义处标注 @Scope 指定，如：@Scope(“prototype”) 通过在 Bean 方法定义处标注 @Scope 指定 Bean 生命周期方法 通过 &lt;bean&gt; 的 init-method 和 destroy-method 属性指定 Bean 实现类的方法名，最多只能指定一个初始化方法和销毁方法 通过在目标方法上标注 @PostConstruct 和 @PreDestory 注解指定初始化或销毁方法，可以定义任意多个 通过 @Bean 的 initMethod 或 destoryMethod 指定一个初始化或销毁方法。对于初始化方法来说，可以直接在方法内部通过代码的方式灵活定义初始化逻辑 Bean 延迟初始化 通过 &lt;bean&gt; 的 lazy-init 属性指定，默认为 default，继承自 &lt;beans&gt; 的 default-lazy-init 设置，该值默认为 false 通过在类定义出标注 @Lazy 指定，如：@Lazy(true) 通过在 Bean 方法定义出标注 @Lazy 指定 适合场景 Bean 实现类来源于第三方类库，如 DataSource、JdbcTemplate 等，因无法在类中标注注解，通过 XML 配置方式较好；命名空间的配置，如 aop、context 等，只能采用基于 XML 的配置 Bean 的实现类时当前项目开发的，可以直接在 Java 类中使用基于注解的配置 优势在于可以通过代码的方式控制 Bean 初始化的整体逻辑，所以如果实例化 Bean 的逻辑比较复杂，则比较适合用基于 Java 类配置的方式 ｜ 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（五）—— IOC 容器之依赖注入]]></title>
      <url>%2F2016%2F11%2F17%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
      <content type="text"><![CDATA[Spring 支持两种依赖注入方式，分别为构造函数注入和属性注入，此外还支持工厂方法注入方式。 构造函数注入构造函数注入由容器调用带参的构造函数来完成，与通过调用指定参数的静态工厂方法来构造 bean 相似。包含构造函数的类是一个没有依赖于容器指定的接口，基类或注释的 POJO，如下所示：123456789public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on a MovieFinder private MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 构造函数参数解析使用参数的类型进行构造函数参数解析匹配。如果 bean 定义的构造函数参数不存在歧义，那么构造函数参数在 &lt;beans/&gt; 中定义的参数顺序和 bean 被实例化时提供给适当的构造函数的参数顺序一致。123456package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ... &#125;&#125; 12345678&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;/bean&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt;&lt;/beans&gt; 按类型匹配入参在 &lt;constructor-arg&gt; 的元素中有一个 type 属性，它为 Spring 提供了判断配置项和构造函数入参对应关系的信息。Spring 的配置文件采用和元素标签顺序无关的策略，在一定程度上保证配置信息的正确性，&lt;constructor-arg&gt; 位置的改变并不会对最终的配置产生影响。1234567891011package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="7500000"/&gt; &lt;constructor-arg type="java.lang.String" value="42"/&gt;&lt;/bean&gt; 按索引匹配入参如果构造函数两个入参的类型相同，仅通过 type 无法确定对应关系，需要通过入参索引的方式进行确定，参数和构造函数参数需要顺序对应。1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="7500000"/&gt; &lt;constructor-arg index="1" value="42"/&gt;&lt;/bean&gt; 按参数名匹配入参使用 @ConstructorProperties 注解指定入参名，在 xml 文件中通过参数名的方式匹配入参。123456789package examples;public class ExampleBean &#123; // Fields omitted @ConstructorProperties(&#123;"years", "ultimateAnswer"&#125;) public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg name="years" value="7500000"/&gt; &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;&lt;/bean&gt; 属性注入属性注入即通过 setXxx() 方法注入 Bean 的属性值或依赖对象，由于属性注入方式具有可选择性和灵活性高的优点，因此属性注入是实际应用中最常见的注入方式。属性注入要求 Bean 提供一个默认的构造函数，并为需要注入的属性提供对应的 Setter 方法。Spring 先调用 Bean 的默认构造函数实例化 Bean 对象，然后通过反射的方式调用 Setter 方法注入属性值。12345678910111213package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public void setYears(int years) &#123; this.years = years; &#125; public void setUltimateAnswer(int ultimateAnswer) &#123; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;property name="years"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/property&gt; &lt;property name="ultimateAnswer"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; 注入参数详解字面值字面值指可用字符串表示的值，且这些值可通过 value 属性进行注入。Spring 容器在内部为字面值提供了编辑器，它可以将以字符串表示的字面值转换为内部变量的相应类型。1234567&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="masterkaoli"/&gt;&lt;/bean&gt; 使用 p-namespace 简化上述的 xml 配置：123456&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="root" p:password="masterkaoli"/&gt; 引用其他 bean使用 ref 指定引用的 bean：1234&lt;!-- in the parent context --&gt;&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt;&lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt; 12345678&lt;!-- in the child (descendant) context --&gt;&lt;!-- bean name is the same as the parent bean --&gt;&lt;bean id="accountService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target"&gt; &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt; &lt;/property&gt; &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt; 内部 Bean内部 Bean 和 Java 代码中匿名内部类相似，没有名字，也不能被其他 Bean 引用，只能在声明出为外部 Bean 提供实例注入。内部 Bean 即使提供了 id、name、scope 属性，也会被忽略，scope 默认为 prototype类型。123456789&lt;bean id="outer" class="..."&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name="target"&gt; &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt; &lt;property name="name" value="Fiona Apple"/&gt; &lt;property name="age" value="25"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 集合类型属性在 , , , 和 元素中，可以设置属性和 Java 集合类型 List, Set, Map 和 Properties 的参数。12345678910111213141516171819202122232425262728293031&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt; &lt;prop key="support"&gt;support@example.org&lt;/prop&gt; &lt;prop key="development"&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name="someList"&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name="someMap"&gt; &lt;map&gt; &lt;entry key="an entry" value="just some string"/&gt; &lt;entry key ="a ref" value-ref="myDataSource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name="someSet"&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 集合合并允许子 &lt;bean&gt; 继承父 &lt;bean&gt; 的同名属性集合元素，并将子 &lt;bean&gt; 中配置的集合属性值和父 &lt;bean&gt; 中配置的同名属性值合并起来作为最终 Bean 的属性值。12345678910111213141516171819&lt;beans&gt; &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="child" parent="parent"&gt; &lt;property name="adminEmails"&gt; &lt;!-- the merge is specified on the child collection definition --&gt; &lt;props merge="true"&gt; &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;beans&gt; 强类型集合JDK5.0 提供了强类型集合的新功能，允许为集合元素指定类型。123456public class Foo &#123; private Map&lt;String, Float&gt; accounts; public void setAccounts(Map&lt;String, Float&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 1234567891011&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="accounts"&gt; &lt;map&gt; &lt;entry key="one" value="9.99"/&gt; &lt;entry key="two" value="2.75"/&gt; &lt;entry key="six" value="3.99"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; null 值和空 string 值参数值为空 String：123&lt;bean class="ExampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt; 参数值为 null：12345&lt;bean class="ExampleBean"&gt; &lt;property name="email"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; 简化配置方式Spring 为字面值、引用 Bean 和集合都提供了简化的配置方式。 使用 p-namespace1234567891011&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean name="classic" class="com.example.ExampleBean"&gt; &lt;property name="email" value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;bean name="p-namespace" class="com.example.ExampleBean" p:email="foo@bar.com"/&gt;&lt;/beans&gt; 使用 c-namespace12345678910111213141516&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt; &lt;!-- traditional declaration --&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;constructor-arg value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;!-- c-namespace declaration --&gt; &lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com"/&gt;&lt;/beans&gt; 级联属性123&lt;bean id="foo" class="foo.Bar"&gt; &lt;property name="fred.bob.sammy" value="123" /&gt;&lt;/bean&gt; foo bean 有一个 fred 属性，在 fred 下有一个 bob 属性， 在 bob 下有一个 sammy 属性。 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（四）—— IOC 容器之 Bean 的生命周期]]></title>
      <url>%2F2016%2F11%2F16%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%20Bean%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[Initialization 回调org.springframework.beans.factory.InitializingBean 接口允许 bean 在容器设置完所有属性后执行初始化工作，初始化工作在实现 InitializingBean 的类中的 afterPropertiesSet() 方法中执行。此外，初始化工作也可通过 @PostConstruct 注解来指定执行初始化工作的方法；或者指定一个 POJO 的初始化方法，然后在 XML 文件中使用 init-method 属性指定在该方法中执行初始化操作。 实现 InitializingBean 接口1&lt;bean id="exampleInitBean" class="examples.ExampleBean"/&gt; 12345public class ExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 使用 @PostConstruct 注解123456public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125;&#125; 使用 init-method 属性1&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt; 12345public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125; Destroy 回调org.springframework.beans.factory.DisposableBean 接口允许 bean 使用销毁回调，销毁工作在实现 DisposableBean 的类中的 destroy() 方法中执行。注解方法使用 @PreDestroy，XML 文件指定 destroy-method 属性即可。 实现 InitializingBean 接口1&lt;bean id="exampleInitBean" class="examples.ExampleBean"/&gt; 12345public class ExampleBean implements InitializingBean &#123; public void destroy() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 使用 @PostConstruct 注解123456public class CachingMovieLister &#123; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; 使用 init-method 属性1&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt; 12345public class ExampleBean &#123; public void cleanup() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 默认的 initialization 和 destroy 方法当做 initialization 和 destroy 工作时，使用 init(), initialize(), dispose() 等类似的方法名有助于我们识别方法的作用。每次我们都需要为每个 bean 设置 init-method 或 destroy-method 属性指定生命周期的回调方法，有一个更加简便的方法，即在 元素中使用 default-init-method 属性指定初始化的方法，则默认 元素下的所有 bean 的初始化方法均为 init()。12345&lt;beans default-init-method="init"&gt; &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt; &lt;property name="blogDao" ref="blogDao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112public class DefaultBlogService implements BlogService &#123; private BlogDao blogDao; public void setBlogDao(BlogDao blogDao) &#123; this.blogDao = blogDao; &#125; // this is (unsurprisingly) the initialization callback method public void init() &#123; if (this.blogDao == null) &#123; throw new IllegalStateException("The [blogDao] property must be set."); &#125; &#125;&#125; default-destroy-method 属性的使用方法也和 default-init-method 一样。 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（三）—— IOC 容器之 BeanFactory 和 ApplicationContext]]></title>
      <url>%2F2016%2F11%2F13%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20IOC%20%E5%AE%B9%E5%99%A8%E4%B9%8B%20BeanFactory%20%E5%92%8C%20ApplicationContext%2F</url>
      <content type="text"><![CDATA[简介BeanFactory 是 Spring 框架最核心的接口，它提高了高级 IOC 的配置机制。BeanFactory 使管理不同类型的 Java 对象成为可能，ApplicationContext 建立在 BeanFactory 的基础之上，提供了更多面向应用的功能，提供了国际化支持和框架事件体系，更易于创建实际应用。BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身，ApplicationContext 面向使用 Spring 框架的开发者。 BeanFactoryBeanFactory 提供了 Spring IOC 的基础功能，但它只能在第三方框架中直接使用。和 BeanFactory 相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，仍然存在于 Spring 中用于与 Spring 集成的大量第三方框架向后兼容的作用。BeanFactory 通常使用在运行于资源有限（内存消耗严重）的嵌入式应用中。 使用 BeanFactory 实现注册一个后处理器（PostProcessor）： 123456DefaultListableBeanFactory factory = new DefaultListableBeanFactory();// populate the factory with bean definitions// now register any needed BeanPostProcessor instancesMyBeanPostProcessor postProcessor = new MyBeanPostProcessor();factory.addBeanPostProcessor(postProcessor);// now start using the factory 使用 BeanFactory 实现注册一个 BeanFactoryPostProcessor： 12345678DefaultListableBeanFactory factory = new DefaultListableBeanFactory();XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));// bring in some property values from a Properties filePropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();cfg.setLocation(new FileSystemResource("jdbc.properties"));// now actually do the replacementcfg.postProcessBeanFactory(factory); ApplicationContextApplicationContext 继承自 BeanFactory，提供了更多面向实际应用的功能。在 BeanFactory 中，很多功能需要以编程的方式实现，而在 ApplicationContext 中则可以通过配置的方式实现。 下图为 ApplicationContext 的继承体系图： ApplicationContext 的主要实现类是 ClassPathXmlApplicationContext，FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext，第一个默认从类路径加载配置文件，第二个默认从文件系统中装载配置文件，第三个可直接传入注解类，通过 register(Class…) 注册类或 scan(String…) 扫描路径 classpath 逐个注册类。 如上图所示，ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此之上还通过其他的接口扩展了 BeanFactory 的功能。这类接口包括： ApplicationEventPublisher：让容器拥有发布 ApplicationContext 事件的功能，包括容器启动时间、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件，并对事件进行响应处理。在 ApplicationContext 抽象实现类 AbstractApplicationContext 中，可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生 ApplicationContext 事件时通知这些事件监听者。 MessageSource：为应用提供 i18n 国际化消息访问的功能。 ResourcePatternResolver：所有 ApplicationContext 实现类都实现了通过 Ant 风格的资源文件路径装载 Spring 的配置文件。 Lifecycle：该接口于 Spring2.0 加入，提供了 start() 和 stop() 两个方法，主要用于控制异步处理过程。具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现，ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。 ConfigurableApplicationContext 继承自 ApplicationContext，增加了两个主要的方法：refresh() 和 close()，让 ApplicationContext 具有启动、刷新和关闭上下文的能力。在 ApplicationContext 关闭时，调用 refresh 可启动 ApplicationContext；在启动状态下调用，则清除缓存并重新装载配置信息。调用 close 关闭 ApplicationContext。 ApplicationContext 的初始化：ApplicationContext 在实例化后和 BeanFactory 一样调用 getBean(beanName) 返回 Bean；在初始化时，BeanFactory 初始化容器时并未实例化 Bean 直至第一次访问 Bean，ApplicationContext 在初始化上下文时实例化所有单实例的 Bean。和基于 XML 文件配置方式的相比，类注解的配置方式可以很容易地让开发者控制 Bean 的初始化过程。 配置文件在类路径下，优先使用 ClassPathXmlApplicationContext，“com/example/context/beans.xml” 等同于 “classpath:com/example/context/beans.xml”： 1234ApplicationContext ctx = new ClassPathXmlApplicationContext("com/example/context/beans.xml");ApplicationContext ctx = new ClassPathXmlApplicationContext( new String[]&#123; "com/beans1.xml", "com/beans2.xml" &#125;); 配置文件在类路径下，优先使用 FileSystemXmlApplicationContext，“com/example/context/beans.xml” 等同于 “file:com/example/context/beans.xml”： 12ApplicationContext ctx = new FileSystemXmlApplicationContext("com/example/context/beans.xml"); 需要解析的是注解类，使用 AnnotationConfigApplicationContext： Bean 类： 1234567891011121314151617181920package com.lake.context;public class Car &#123; private String brand; private int maxSpeed; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125;&#125; 带注解的 POJO 类： 12345678910111213package com.lake.context;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class Beans &#123; @Bean(name = "car") public Car buildCar() &#123; Car car = new Car(); car.setBrand("奔驰"); car.setMaxSpeed(300); return car; &#125;&#125; 通过带 @Configuration 的 POJO 类启动容器： 12345678910package com.lake.context;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class AnnotationApplicantionContext &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(Beans.class); Car car = context.getBean("car", Car.class); car.getBrand(); &#125;&#125; WebApplicationContextWebApplicationContext 为 Web 应用而准备，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。Spring 提供了工具类 WebApplicationContextUtils，通过 getWebApplicationContext(ServletContext sc) 获取 WebApplicationContext 实例。 ConfigurableWebApplicationContext 继承自 WebApplicationContext，它允许通过配置的方式实例化 WebApplicationContext，它有两个重要的方法： setServletContext(ServletContext servletContext)：为 Spring 设置 WebApplicationContext。 setConfigLocations(String[] configLocations)：设置 Spring 配置文件地址，相对于 Web 根目录，如 /WEB-INF/lake-dao.xml，/WEB-INF/lake-service.xml 等。但用户也可使用带资源类型前缀的地址，如 classpath:com/example/context/beans.xml 等。 WebApplicationContext 初始化WebApplicationContext 需要 ServletContext 实例，它必须在拥有 Web 容器的情况下才能完成启动工作，和通常的 Web 开发类似，在 web.xml 中配置自启动的 Servlet 或容器监听器（ServletContextListener），即可完成启动 Spring WebApplicationContext 的工作。Spring 提供了用于启动 WebApplicationContext 的 Servlet 和 Web 容器监听器： org.springframework.web.context.ContextLoaderServlet org.springframework.web.context.ContextLoaderListener 两者都实现了启动 WebApplicationContext 实例的逻辑，只要根据 Web 容器的具体情况选择其一，并在 web.xml 中完成配置即可。 ContextLoaderListener 启动 WebApplicationContext:123456789&lt;!-- 指定配置文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 设置Web容器监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 在不支持容器监听器的低版本 Web 容器中，使用 ContextLoaderServlet：1234567891011&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 声明自启动的Servlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springContextLoaderServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;!-- 启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 标准和自定义事件ApplicationContext 通过 ApplicationEvent 和 ApplicationListener 接口提供事件处理，当某个 bean 实现了 ApplicationListener 接口时，当 ApplicationEvent 发布给 ApplicationContext 时，该 bean 会被告知。 标准事件 ContextRefreshedEvent：当 ApplicationContext 被初始化或刷新时发布事件。这里的初始化是指所有的 beans 被加载，后处理器 beans 被检测并激活，单例被预实例化，ApplicationContext 对象已准备好并可用。当上下文关闭时，refresh 可以被多次触发，这样的 ApplicationContext 支持热刷新。XmlWebApplicationContext 支持热刷新，而 GenericApplicationContext 不支持。 ContextStartedEvent：ApplicationContext 被启动时发布事件，使用 ConfigurableApplicationContext 接口的 start() 方法。这里的启动意味着 beans 接收一个显式的启动信号，该信号用于在显式的停止之后重新启动 beans，也可以用于启动没有被配置成自动启动的组件。 ContextStoppedEvent：ApplicationContext 被停止时发布事件，使用 ConfigurableApplicationContext 接口的 stop() 方法。 RequestHandledEvent：告知所有 beans 一个 HTTP 请求已被处理的特定的 web 事件，当请求完成时事件将会被发布，该事件只能通过 Spring 的 DispatcherServlet 应用于 Web 应用中。 自定义事件自定义事件需要继承 Spring 的 ApplicationEvent 基类：12345678910public class BlackListEvent extends ApplicationEvent &#123; private final String address; private final String test; public BlackListEvent(Object source, String address, String test) &#123; super(source); this.address = address; this.test = test; &#125; // accessor and other methods...&#125; 调用 ApplicationEventPublisher 的 publishEvent() 方法发布自定义的 ApplicationEvent，该类需要实现 ApplicationEventPublisherAware 接口并作为 bean 来注册。在配置期间，Spring 容器会检测到实现了 ApplicationEventPublisherAware 接口的 EmailService 并自动的调用 setApplicationEventPublisher() 方法。123456789101112131415161718public class EmailService implements ApplicationEventPublisherAware &#123; private List&lt;String&gt; blackList; private ApplicationEventPublisher publisher; public void setBlackList(List&lt;String&gt; blackList) &#123; this.blackList = blackList; &#125; public void setApplicationEventPublisher(ApplicationEventPublisher publisher) &#123; this.publisher = publisher; &#125; public void sendEmail(String address, String text) &#123; if (blackList.contains(address)) &#123; BlackListEvent event = new BlackListEvent(this, address, text); publisher.publishEvent(event); return; &#125; // send email... &#125;&#125; 创建一个实现 ApplicationListener 接口的类，并作为 bean 来注册，以此接受自定义的 ApplicationEvent。123456789public class BlackListNotifier implements ApplicationListener&lt;BlackListEvent&gt; &#123; private String notificationAddress; public void setNotificationAddress(String notificationAddress) &#123; this.notificationAddress = notificationAddress; &#125; public void onApplicationEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress... &#125;&#125; 下面的代码用于配置和注册上述的类：123456789101112&lt;bean id="emailService" class="example.EmailService"&gt; &lt;property name="blackList"&gt; &lt;list&gt; &lt;value&gt;known.spammer@example.org&lt;/value&gt; &lt;value&gt;known.hacker@example.org&lt;/value&gt; &lt;value&gt;john.doe@example.org&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="blackListNotifier" class="example.BlackListNotifier"&gt; &lt;property name="notificationAddress" value="blacklist@example.org"/&gt; &lt;/bean&gt; 当 emailService 的 sendEmail() 方法被调用时，如果有任何邮件需要被加入黑名单，那么自定事件 BlackListEvent 会被发布。blackListNotifier bean 被注册作为 ApplicationListener 并接收 BlackListEvent。 基于注解的事件监听器12345678910public class BlackListNotifier &#123; private String notificationAddress; public void setNotificationAddress(String notificationAddress) &#123; this.notificationAddress = notificationAddress; &#125; @EventListener public void processBlackListEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress... &#125;&#125; 异步监听器12345@EventListener@Asyncpublic void processBlackListEvent(BlackListEvent event) &#123; // BlackListEvent is processed in a separate thread&#125; 顺序监听器12345@EventListener@Order(42)public void processBlackListEvent(BlackListEvent event) &#123; // notify appropriate parties via notificationAddress...&#125; 参考资料：Spring 3.x 企业应用开发实战Spring Framework Reference Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（二）—— 基本概念的理解]]></title>
      <url>%2F2016%2F11%2F12%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[控制反转（IOC）控制反转（Inversion of Control），即依赖注入（Dependency Injection），它们两个是一个东西的两种不同的说法。依赖注入是一个程序设计模式和架构模型，是控制反转的特殊实现，它指一个对象应用另外一个对象来提供一个特殊的能力。IOC 是 Spring 的核心，理解它的时候可以分为控制和反转两步来理解。举个例子：你现在接到一份工作，但是你没空，你把工作交给你的好友来完成，你对工作如何完成已不关心，控制权移交到你的好友手中，他可以决定如何完成工作，你只需要等待结果即可。如上所述，控制即对工作的控制权，反转可理解为原先你所掌握的工作的控制权移交到好友身上。在 Spring 中理解为某一接口具体实现类的控制权从调用类中移除，转而由第三方控制（类似对成员变量的赋值的控制权从代码移交到 xml 配置文件中）。依赖注入理解为让调用者对某一接口实现类的依赖关系由第三方（容器或协助类）注入，以移除调用类对某一接口实现类的依赖。 面向切面编程（AOP）面相切面编程（AOP）是对面相对象编程（OOP）的补充，OOP 主要的模块单元是 class (类)，而 AOP 是 aspect（切面），切面使得诸如事务管理等跨越多个类型和对象的关注点模块化。AOP 通过横向抽取机制，为无法通过纵向继承体系进行抽象的类的重复性代码提供了解决方案。 连接点（Join point）在程序执行过程中具有边界性质的特定点，比如某个类初始化前后、类的某个方法调用前后或者处理异常的时候。在 Spring AOP 中，一个连接点总是代表一个方法的执行。 增强（Advice）在切面的某个特定的连接点上执行的动作。增强有各种类型，其中包括 around、before 和 after 等。Spring 以拦截器作增强模型，并维护一个以连接点为中心的拦截器链。 切点（Pointcut）用来匹配连接点的断言。增强关联一个切点表达式，并在匹配这个切入点的连接点上运行。AOP 通过切点定位特定的连接点：Spring 默认使用切点语法 AspectJ。通过数据库查询的概念来理解切点和连接点：连接点相当于数据库中的记录，而切点相当于查询条件，一个切点可以匹配多个连接点。 切面（Aspect）切面由切点和增强组成，包括横切逻辑和连接点的定义。在 Spring AOP 中，切面可以使用通用类（schema-based 基于模式的风格）或者在普通类中以 @Aspect 注解（@AspectJ 注解样式）来实现。 引介（Introduction）引介是一种特殊的增强，它为类添加一些属性和方法。一个业务类原先没有实现某个接口，通过 AOP 的引介功能，可以动态地为该业务添加接口的实现逻辑，让业务类成为该接口的实现类。例如：使用一个引介来使 bean 实现 IsModified 接口，以便简化缓存机制。 目标对象（Target object）被一个或多个切面所增强的对象。因为 Spring AOP 是使用运行时代理来实现的，所以这个对象总是一个代理对象。 代理（Proxy）一个类被 AOP 织入增强后，就生成一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。在 Spring 中，AOP 代理可以是 JDK 动态代理或者 CGLIB 代理。 织入（Weaving） 织入是将增强添加到目标类具体连接点上的过程。AOP 有三种织入方式： 编译期织入，要求特殊的 Java 编译器 类装载期织入，要求使用特殊的类装载器 动态代理织入，在运行期为目标类添加增强生成子类的方式 Spring 采用动态代理织入（即在运行时完成织入），而 AspectJ 采用编译期和类装载期织入。 Spring 框架组件列表 GroupId ArtifactId 描述 org.springframework spring-aop 支持基于代理的 AOP org.springframework spring-aspects 基于 AspectJ 的切面 org.springframework spring-beans 包含 Groovy 的 Beans 支持 org.springframework spring-context 应用程序上下文运行时，包括调度和远程抽象 org.springframework spring-context-support 支持将常见的第三方库集成到 Spring 应用程序上下文的类中 org.springframework spring-core Spring 核心，为其它模块所用 org.springframework spring-expression Spring 表达式（SpEL） org.springframework spring-instrument JVM 引导用的代理工具 org.springframework spring-instrument-tomcat Tomcat 的代理工具 org.springframework spring-jdbc JDBC 支持包，包括 DataSource 设置和 JDBC 访问支持 org.springframework spring-jms JMS 支持包，包括用于发送和接收 JMS 消息的帮助类 org.springframework spring-messaging 支持消息架构和协议 org.springframework spring-orm 对象/关系映射，包含对 JPA 和 Hibernate 支持 org.springframework spring-oxm 对象/XML映射 org.springframework spring-test 支持单元测试和集成测试的 Spring 组件 org.springframework spring-tx 事务基础设施，包括 DAO 支持和 JCA 集成 org.springframework spring-web Web 支持包，包括客户端和 Web 远程处理 org.springframework spring-webmvc REST Web 服务和 Web 应用程序实现的 model-view-controller org.springframework spring-webmvc-portlet MVC 实现在 Portlet 环境中的使用 org.springframework spring-websocket WebSocket 和 SockJS 实现，包含 STOMP 支持 参考资料：中文翻译《Spring Framework 4.x参考文档》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring笔记（一）—— 版本新特性]]></title>
      <url>%2F2016%2F11%2F12%2FSpring%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[1. spring 2.0 和 2.5 的新特性1.1 简介JDK 版本要在 1.4.2 以上，Java 5 和 Java 6 都支持。Spring 框架继续保持对 Java EE 1.3 及以后版本的兼容，完全支持 Java EE 5。对服务器（应用服务器和Web服务器）的支持： WebLogic：8.1、9.0、9.2、10 WebSphere：5.1、6.0、6.1 OC4J(Oracle)：10.1.3、11 JBoss：3.2、4.0、4.2 Tomcat：4.1、5.0、5.5、6.0 Jetty：4.2、5.1、6.1 Resin：2.1、3.0、3.1 GlassFish：v1、v2 1.2 控制反转（IOC）容器1.2.1 新的 bean 作用域Spring2.0：IoC 容器中只支持 singleton 和 prototype 两个不同的 bean 作用域。Spring2.5：还支持 request、session、global session 三个在 web 环境下使用的 bean 作用域，且提供了hooks，可以让用户创建自己的作用域。 1.2.2 更简单的 XML 配置Spring2.5 对 Spring2.0 的 DTD 进行了更新，spring-beans-2.0.dtd 可在发布包下的 dist/resources 下找到。12&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt; 1.2.3 可扩展的 XML 编写作为一个应用程序开发人员或第三方框架或产品的供应商，开发自定义标签，供其他开发人员把这些标签嵌入到自己的Spring配置文件里。 1.2.4 Annotation（注解）驱动配置Spring 2.0 引入了一些用于配置的 annotation, 包括 @Transactional, @Required, @PersistenceContext /@PersistenceUnit。Spring 2.5 引入了用于配置的完整的 Annotation 集合: @Autowired，以及对 JSR-250 注解 @Resource, @PostConstruct, @PreDestroy 的支持。 1.2.5 在 classpath 中自动搜索组件组件类会注解为 stereotype: @Component, @Repository, @Service, @Controller，取决于程序的上下文配置，这些组件会被自动搜索到，并且转变为 Spring bean 定义，而不需要为每个类都进行明确的配置。 1.3 面向切面编程（AOP）1.3.1 更加简单的 AOP XML 配置1.3.2 对 @AspectJ 切面的支持1.3.3 对 bean 命名 pointcut 的支持1.3.4 对 AspectJ 装载时织入的支持1.4 中间层1.4.1 在XML里更为简单的声明性事务配置Spring 2.5 支持方便的注解驱动的事务管理，通过 context:load-time-weaver 和 tx:annotation-driven mode=”aspectj” 的联合使用进行事务管理。 1.4.2 对 Websphere 事务管理的完整支持要自动探测底层的 JTA 事务平台，可以使用 Spring 2.5 的新 tx:jta-transaction-manager 配置元素。它会自动探测 BEA WebLogic 和 IBM WebSphere，注册正确的 PlatformTransactionManager。 1.4.3 JPASpring 2.5 对 OpenJPA 的支持升级到了 OpenJPA 1.0，支持 savepoint 这样的高级特性。 1.4.4 异步的JMS在 Spring 2.0 之前，Spring 的 JMS 的作用局限于发送消息和同步接收消息。Spring 2.0 提供对异步消息接收的完整支持。在 Spring 2.5 中， JCA 风格的异步消息监听器设置也通过 GenericMessageEndpointManager 工具得到了支持。 1.4.5 JDBC引入了新类，Spring 2.5 扩充了 SimpleJdbcTemplate 的功能，引入了 SimpleJdbcCall和 SimpleJdbcInsert 操作对象。 1.5 Web 层1.5.1 Spring MVC 合理的默认值1.5.2 Portlet 框架1.5.3 基于 Annotation 的控制器1.5.4 Spring MVC 的表单标签库1.5.5 对 Tiles 2，JSF 1.2，JAX-WS 支持2. spring 3.x 的新特性2.1 spring 3.02.1.1 Spring3.0 以后分成多个 jar 包 org.springframework.aop， 包含在应用中使用Spring的AOP特性时所需的类。 org.springframework.asm，Spring独立的asm程序，Spring2.5.6的时候需要 asm.jar 包，3.0开始提供自己独立的asm.jar org.springframework.aspects，提供对AspectJ的支持，以方便的将面向切面的功能集成进IDE中，比如Eclipse AJDT. org.springframework.beans，所有应用都要用到，它包含访问配置文件，创建和管理Bean以及进行反转共控制和依赖注入操作时所需的类 org.springframework.context，为 Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext 特性时所需的全部类，JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如 Velocity、 FreeMarker、 JasperReports 集成的类， 以及校验 Validation 方面的相关类。 org.springframework.context.support，包含支持缓存Cache（ehcache）JCA、JMX、邮件服务（Java Mail、Mail）COS、任务计划Scheduling（Timer、Quartz）方面的类。 org.springframework.core，包含 Spring 框架基本的核心工具类，Spring 其它组件要都要使用到这个包里的 类，是其它组件的基本核心。 org.springframework.expression，包含Spring 表达式语言相关的类，应用使用到SpEL时需要添加这个jar包。 org.springframework.instrument.tomcat，Spring3.0对Tomcat的连接池的集成。 org.springframework.instrument，Spring3.0 对服务器的代理接口。 org.springframework.jdbc，包含对 Spring 对 JDBC 数据访问进行封装的所有类。 org.springframework.jms，提供了对JMS1.0.2/1.1 的支持类。 org.springframework.orm，包含Spring对DAO特性集进行了扩展，使其支持iBATIS、JDO、OJB、TopLink，因+ 为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含 spring-dao.jar包。 org.springframework.oxm，Spring 对 Object/XMl 的映射支持,可以让Java与XML之间来回切换。 org.springframework.test，对Junit等测试框架的简单封装。 org.springframework.transaction，为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 org.springframework.web，包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 org.springframework.web.portlet，对SpringMVC的增强，包含SpringMVC相关的类 org.springframework.web.servlet，对J2EE6.0的Servlet3.0的支持。 org.springframework.web.struts，对Struts框架支持，可以更方便更容易的集成Struts框架。 2.1.2 新增特性 Spring 表达式语言 增强的 IOC 和基于 java 的 Bean 元数据 通用类型转换系统和字段格式 来自于 Srping Web Services 项目的对象和 XML 之间的映射 增强的 REST 支持 @MVC additions （Spring的 MVC 注解增强） 声明式模型验证 提前对 JEE6 的支持 嵌入式数据库的支持 2.1.3 基于 Java 5 的核心API的更新 BeanFactory接口尽可能的返回明确的实例： T getBean(Class requiredType) getBean(String name, Class requiredType) Map getBeansOfType(Class type) Spring 的 TaskExecutor 继承 java.util.concurrent.Executor 接口 扩展的子接口 AsyncTaskExecutor 支持标准的具有返回结果 Futures 的 Callables 基于 Java5 的 API 和 SPI 转换器 无状态的 ConversionService 和 Converters 取代标准的 JDK PropertyEditors 类型化的 ApplicationListener 2.1.4 Spring 表达式语言（简称SpEL）SpEL 使得 java 具有动态语言的风格，可以在运行时获取表达式的值。依赖注入时可以使用 SpEL 表达式语言, 不再只是原来简单的属性文件变量(xml)。示例： xml 配置： 123456&lt;bean class="mycompany.RewardsTestDatabase"&gt; &lt;property name="databaseName" value="#&#123;systemProperties.databaseName&#125;"/&gt; &lt;property name="keyGenerator" value="#&#123;strategyBean.databaseKeyGenerator&#125;"/&gt;&lt;/bean&gt; java 代码： 12345678@Repositorypublic class RewardsTestDatabase &#123; @Value("#&#123;systemProperties.databaseName&#125;") public void setDatabaseName(String dbName) &#123; ... &#125; @Value("#&#123;strategyBean.databaseKeyGenerator&#125;") public void setKeyGenerator(KeyGenerator kg) &#123; ... &#125;&#125; 2.1.5 增强的 IOC 和基于 java 的 bean 配置更多的注解的支持：@Configuration，@Bean，@DependsOn， @Primary，@Lazy，@Import，@ImportResource，@Value示例： xml 配置： 123&lt;context:component-scan base-package="org.example.config"/&gt;&lt;util:properties id="jdbcProperties" location="classpath:org/example/config/jdbc.properties"/&gt; 也可以使用如下代码来代替 xml 的配置： 12ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); FooService fooService = ctx.getBean(FooService.class); java 代码： 12345678910111213141516171819202122232425262728package org.example.config;...@Configurationpublic class AppConfig &#123; private @Value("#&#123;jdbcProperties.url&#125;") String jdbcUrl; private @Value("#&#123;jdbcProperties.username&#125;") String username; private @Value("#&#123;jdbcProperties.password&#125;") String password; @Bean public FooService fooService() &#123; return new FooServiceImpl(fooRepository()); &#125; @Bean public FooRepository fooRepository() &#123; return new HibernateFooRepository(sessionFactory()); &#125; @Bean public SessionFactory sessionFactory() &#123; // wire up a session factory AnnotationSessionFactoryBean asFactoryBean = new AnnotationSessionFactoryBean(); asFactoryBean.setDataSource(dataSource()); // additional config return asFactoryBean.getObject(); &#125; @Bean public DataSource dataSource() &#123; return new DriverManagerDataSource(jdbcUrl, username, password); &#125;&#125; 2.1.6 通用类型转换系统和字段格式化系统Spring3.0 加入了一个通用的类型转换系统，它被 SpEL 用作类型转换，并且可能被一个 Spring 容器使用，用于当绑定 bean 的属性值时进行类型转换。此外还增加了一个字段格式化系统，它提供了更简单且强大的功能以替代在客户端环境下的 Javabean 的 PropertyEidtors。 2.1.7 声明式模型验证支持 JSR303，使用 Hibernate Validator 作为默认实现：12345678public class Person &#123; @NotNull @Max(64) private String name; @Min(0) private int age; &#125; 2.2 spring 3.12.2.1 新增特性 Cache 抽象 Bean 定义配置文件 Environment 抽象 PropertySource 抽象 注解代替 xml 配置 对 Hibernate 4.x 的支持 TestContext 框架对 @Configuration 和 Bean 定义配置文件 的支持 更为简洁的构造函数注入 c: namespace 非标准 setter 类的注入 Servlet 3 code-based configuration of Servlet Container 的支持 Servlet 3 MultipartResolver 的支持 改善了 O/R 映射支持，允许无persistence.xml的JPA包扫描 可以在 controller 中，使用 annotation 临时指定特殊的 Mapping 或者 ExceptionHandler，而且整个体系更加灵活和可扩展。 2.3 spring 3.22.3.1 新增特性 支持基于Servlet 3的异步请求处理 Spring MVC Test框架 内容协商（Content Negotiation）改进。ContentNeogtiationStrategy 现在可以根据传入请求确定请求的媒体类型。可用的实现是基于文件扩展名、查询参数、“Accept”头或者一个固定的内容类型。 @ControllerAdvice 矩阵变量（Matrix Variables），增加了 @MatrixVariable 用于从请求URI中提取矩阵变量。 增加了一个抽象基础类用于支持基于代码的Servlet 3+容器初始化。 ResponseEntityExceptionHandler，用于处理异常消息的转换，和 DefaultHandlerExceptionResolver 的区别在于，这个类返回 ModelAndView。 RestTemplate 和 @RequestBody 的参数支持泛型。 支持Jackson JSON 2 支持Tiles 3 改进 @RequestBody。@RequestBody 和 @RequestPart 的参数现在可以跟随Error参数，使它可以在 @RequestMapping 方法中处理验证的错误，@RequestBody 现在有一个 required 属性。 HTTP PATCH 方法。HTTP PATCH方法现在可用于@RequestMapping 拦截器（Interceptor）支持 URL patterns 在注入点（Injection Point）和Bean方法定义中使用元注解 初步支持JCache 0.5 @DateTimeFormat不再依赖Joda Time 全局日期时间格式化 新的测试特性 并发性的微调 基于Gradle的构建系统，并迁移到GitHub 支持Java SE 7和OpenJDK 7 3. spring 4.x 的新特性3.1 spring 4.03.1.1 新增特性 删除了被丢弃的包和方法 Java 8 的支持，最低需要 Java 6 使用 Java EE 6 或以上的版本来作为基线，同时包含了相关的 JPA2.0 和 Servlet3.0 的规范 使用 Groovy 的 DSL（DomainSpecific Languages）来定义 Bean 核心容器的改进 Spring 注入 Bean 的时候把泛型类型当成一种形式的限定符。使用 Spring DataRepository 可以方便的插入特定的实现：@Autowired Repository customerRepository。 使用 Spring 的元注解支持，可以开发自定义注解来公开源注解的特定属性。 当自动装配到 lists 和 arrays 时，Beans 可以被排序，支持 @Order 注解和 Ordered 接口两种方式。 @Lazy 注解可以用在注入点以及 @Bean 定义上。 引入 @Description 注解,开发人员可以使用基于Java 方式的配置。 根据条件筛选 Beans 的广义模型通过 @Conditional 注解加入。这和@Profile支持的类似，但是允许以编程式开发用户定义的策略。 基于 CGLIB 的代理类不在需要默认的构造方法。 框架支持管理时区。 常规 Web 改进 在 Spring MVC 应用中使用新的 @RestController 注解时，不再需要给 @RequestMapping 的方法添加 @ResponseBody 注解。 AsyncRestTemplate 类已被添加进来，当开发 REST 客户端时，允许非阻塞异步支持。 当开发 Spring MVC 应用时，Spring 现在提供了全面的时区支持 WebSocket, SockJS 和 STOMP 消息 测试改进，引入了几个用于单元测试和集成测试的新功能 几乎 spring-test 模块中所有的注解（例如：@ContextConfiguration、@WebAppConfiguration、@ContextHierarchy、@ActiveProfiles 等等)可以用作元注解来创建自定义的 composed annotations 并且可以减少测试套件的配置。 现在可以以编程方式解决 Bean 定义配置文件的激活。只需要实现一个自定义的 ActiveProfilesResolver，并且通过 @ActiveProfiles的resolver 属性注册。 新的 SocketUtils 类被引入到了 spring-core 模块。 3.2 spring 4.13.2.1 新增特性 核心部分基本上无变化，提供了 DirectFieldAccessor 用于直接字段访问、yaml 配置、SpEL 的字节码编译化、BackOff 退避算法的基本实现、Base64Utils、SmartInitializingSingleton等； 在任务调度和事件机制上加入了异常处理部分； cache 部分加入 jcache 的集成、类级别的 @CacheConfig 的支持、CacheResolver； mvc 部分提供了一些视图解析器的 mvc 标签实现简化配置、提供了 GroovyWebApplicationContext 用于 Groovy web 集成、提供了 Gson、protobuf 的 HttpMessageConverter、静态资源处理方面添加了 resolver和 transformer、提供了对 groovy-templates 模板的支持、JSONP 的支持、对 Jackson 的 @JsonView 的支持等； 提供了页面自动化测试框架 Spring MVC Test HtmlUnit； test 部分提供了更便利的 @sql 标签来执行测试脚本的初始化、MockRestServiceServer 对 AyncRestTemplate 支持、MockMvcConfigurer 来全局配置 MockMvc； 提供了对 Java 8 Optional 的支持（ObjectToOptionalConverter 实现；可以在MVC中如 @RequestParam 等注解的绑定）、从Spring 4.1起 Ehcache 支持需要 EhCache 2.5 或更高版本、兼容 Quartz 2.1.4、支持 javax.annotation.Priority（等价于@Order）、JMS API的增强、SpringJUnit4ClassRunner 需要 JUnit 4.9或更高版本支持。 参考资料：开涛的博客–Spring 4.1 新特性——综述BigZ的专栏–Spring 4.0 新功能和增强中文翻译 Spring Framework 4.x参考文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F11%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github 与 Hexo 搭建博客步骤（使用 Next 主题）]]></title>
      <url>%2F2016%2F11%2F11%2FGithub%E4%B8%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[1. 安装前的准备Hexo 是一个快速简单并且强大的博客框架，使用者可以使用 markdown 语法编写文章，然后通过 hexo 生成带有主题的静态文件，并上传到 github，生成的 html 文件可以在浏览器上访问。本安装教程是在 ubuntu 平台上进行的，其他平台请另寻他处。安装前 Hexo 前需要先安装 Node.js 和 Git，在后面会描述其安装过程。 2. 安装 Git使用如下命令安装 Git，在这之后可以先了解 git 简单命令的使用，推荐：廖雪峰的Git教程。 1$ sudo apt-get install git-core 3. 安装 Node.js我们可以使用 nvm 来安装 Node.js ，方法如下：1curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh 或1$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/master/install.sh | sh 安装完 nvm 之后重启窗口安装 Node.js：1$ nvm install stable 如果不想使用命令安装可以直接下载 Node.js 的安装包安装。下载完 linux 下的压缩包后，将其复制到 /usr/local 目录下，并使用 tar -xvJf + 文件名，对压缩包进行解压，更改解压后的文件夹的权限为755。修改环境变量，使用 vim 修改 /etc/profile，在文件末尾添加两行：123# node.jsexport NODE=/usr/local/node-v6.9.1-linux-x64export PATH=$&#123;NODE&#125;/bin:$PATH 之后执行命令 source /etc/profile，使用 node -v 命令查看版本号。 4. 安装 Hexo使用 npm 安装 hexo：1234$ sudo apt-get install npm$ sudo apt-get update$ sudo apt-get install nodejs-legacy$ sudo npm install -g hexo-cli 经过一段时间的等待，会在终端显示如下树状结果，hexo 安装完毕。 当 hexo 安装完毕，使用如下命令初始化 hexo 目录并安装依赖，生成的目录在当前所在的目录之下。123$ hexo init &lt;folder&gt; # 初始化 hexo 并创建目录$ cd &lt;folder&gt; # 切换到目录之下$ npm install # 安装依赖包 hexo 常用命令：1234$ hexo g #完整命令为hexo generate，用于生成静态文件$ hexo s #完整命令为hexo server，用于启动服务器，主要用来本地预览$ hexo d #完整命令为hexo deploy，用于将本地文件发布到github上$ hexo n #完整命令为hexo new，用于新建一篇文章 在本地开启博客，用浏览器访问 http://localhost:4000/：12$ hexo g$ hexo s 5. 注册 Github 并创建 repository到 Github 官网注册 Github 账号，登录进入个人主页选择 Repositories，再点击旁边的 NEW 按钮创建新的 repository，名字的格式必须为 name.github.io，例如：windows7lake.github.io。 6. hexo 的配置整个博客的配置文件，位于 hexo\_config.yml，通过它，我们可以对整个博客进行配置。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Lio's Blog # 网站即博客的标题subtitle: No pains no gains! # 博客的副标题description: No pains no gains, Believes oneself, Nothing impossible! # 博客的描述author: Lio Lin # 作者language: zh-CN # 语言timezone:# URL 设置自己的域名## If your site is put in a subdirectory,## set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # 新创建的文章的默认文件名default_layout: post titlecase: false # 将标题转换为标题大小写external_link: true # 在新的标签中打开外部连接filename_case: 0 # 0 为默认; 1 为小写; 2 为大写render_drafts: false # 是否显示草稿post_asset_folder: falserelative_link: false # 是否创建相对于根文件夹的链接future: truehighlight: # 代码块设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 每页显示的文章数，0 表示不分页pagination_dir: page # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 主题名# Deployment 部署到 github 的配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/windows7lake/windows7lake.github.io branch: master 使用如下命令克隆 Next 主题到我们的本地博客之下：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 主题的配置文件，位于 hexo\theme\主题名\_config.yml，对主题的设置。这里对主题的配置可以参考 NexT 官网。 7. 将本地 Hexo 发布到 Github在本地创建 ssh key：1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的 your_email@youremail.com 改为自己的邮箱，之后会要求确认路径和输入密码，一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。 回到 github，进入 Settings，选择 SSH and GPG Keys -&gt; New SSH Key，title 随便填，粘贴 key。为了验证是否成功，输入：1$ ssh -T git@github.com 如果是第一次的会提示是否 continue，输入 yes 就会看到：You’ve successfully authenticated， but GitHub does not provide shell access ，这就表示已成功连上 github。 接下来我们要做的就是把本地仓库传到 github 上去，在此之前还需要设置 username 和 email，因为 github 每次 commit 都会记录他们。12$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 发布本地博客内容到 Github，需切换到博客目录下，执行如下两条命令，执行如下的第二个命令，可能会要你输入用户名和密码，皆为注册 Github 时的数据，输入密码是不显示任何东西的，输入完毕回车即可。12$ hexo g$ hexo d 如果输入 hexo d 后遇到 ERROR Deployer not found: Git，则使用命令 npm install hexo-deployer-git –save 即可。]]></content>
    </entry>

    
  
  
</search>
